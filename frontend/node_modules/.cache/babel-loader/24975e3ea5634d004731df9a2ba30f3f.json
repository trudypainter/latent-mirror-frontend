{"ast":null,"code":"import _get from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _classCallCheck from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nvar boundingBox = /* @__PURE__ */new Box3();\nvar MeshBVHRootVisualizer = /*#__PURE__*/function (_Object3D) {\n  _inherits(MeshBVHRootVisualizer, _Object3D);\n  var _super = _createSuper(MeshBVHRootVisualizer);\n  function MeshBVHRootVisualizer(mesh, material) {\n    var _this;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    var group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, MeshBVHRootVisualizer);\n    _this = _super.call(this);\n    _this.material = material;\n    _this.geometry = new BufferGeometry();\n    _this.name = 'MeshBVHRootVisualizer';\n    _this.depth = depth;\n    _this.displayParents = false;\n    _this.mesh = mesh;\n    _this.displayEdges = true;\n    _this._group = group;\n    return _this;\n  }\n  _createClass(MeshBVHRootVisualizer, [{\n    key: \"isMesh\",\n    get: function get() {\n      return !this.displayEdges;\n    }\n  }, {\n    key: \"isLineSegments\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }, {\n    key: \"isLine\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast() {}\n  }, {\n    key: \"update\",\n    value: function update() {\n      var geometry = this.geometry;\n      var boundsTree = this.mesh.geometry.boundsTree;\n      var group = this._group;\n      geometry.dispose();\n      this.visible = false;\n      if (boundsTree) {\n        // count the number of bounds required\n        var targetDepth = this.depth - 1;\n        var displayParents = this.displayParents;\n        var boundsCount = 0;\n        boundsTree.traverse(function (depth, isLeaf) {\n          if (depth === targetDepth || isLeaf) {\n            boundsCount++;\n            return true;\n          } else if (displayParents) {\n            boundsCount++;\n          }\n        }, group);\n\n        // fill in the position buffer with the bounds corners\n        var posIndex = 0;\n        var positionArray = new Float32Array(8 * 3 * boundsCount);\n        boundsTree.traverse(function (depth, isLeaf, boundingData) {\n          var terminate = depth === targetDepth || isLeaf;\n          if (terminate || displayParents) {\n            arrayToBox(0, boundingData, boundingBox);\n            var min = boundingBox.min,\n              max = boundingBox.max;\n            for (var x = -1; x <= 1; x += 2) {\n              var xVal = x < 0 ? min.x : max.x;\n              for (var y = -1; y <= 1; y += 2) {\n                var yVal = y < 0 ? min.y : max.y;\n                for (var z = -1; z <= 1; z += 2) {\n                  var zVal = z < 0 ? min.z : max.z;\n                  positionArray[posIndex + 0] = xVal;\n                  positionArray[posIndex + 1] = yVal;\n                  positionArray[posIndex + 2] = zVal;\n                  posIndex += 3;\n                }\n              }\n            }\n            return terminate;\n          }\n        }, group);\n        var indexArray;\n        var indices;\n        if (this.displayEdges) {\n          // fill in the index buffer to point to the corner points\n          indices = new Uint8Array([\n          // x axis\n          0, 4, 1, 5, 2, 6, 3, 7,\n          // y axis\n          0, 2, 1, 3, 4, 6, 5, 7,\n          // z axis\n          0, 1, 2, 3, 4, 5, 6, 7]);\n        } else {\n          indices = new Uint8Array([\n          // X-, X+\n          0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5,\n          // Y-, Y+\n          1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6,\n          // Z-, Z+\n          0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n        }\n        if (positionArray.length > 65535) {\n          indexArray = new Uint32Array(indices.length * boundsCount);\n        } else {\n          indexArray = new Uint16Array(indices.length * boundsCount);\n        }\n        var indexLength = indices.length;\n        for (var i = 0; i < boundsCount; i++) {\n          var posOffset = i * 8;\n          var indexOffset = i * indexLength;\n          for (var j = 0; j < indexLength; j++) {\n            indexArray[indexOffset + j] = posOffset + indices[j];\n          }\n        }\n\n        // update the geometry\n        geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n        geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n        this.visible = true;\n      }\n    }\n  }]);\n  return MeshBVHRootVisualizer;\n}(Object3D);\nvar MeshBVHVisualizer = /*#__PURE__*/function (_Group) {\n  _inherits(MeshBVHVisualizer, _Group);\n  var _super2 = _createSuper(MeshBVHVisualizer);\n  function MeshBVHVisualizer(mesh) {\n    var _this2;\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    _classCallCheck(this, MeshBVHVisualizer);\n    _this2 = _super2.call(this);\n    _this2.name = 'MeshBVHVisualizer';\n    _this2.depth = depth;\n    _this2.mesh = mesh;\n    _this2.displayParents = false;\n    _this2.displayEdges = true;\n    _this2._roots = [];\n    var edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    var meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    _this2.edgeMaterial = edgeMaterial;\n    _this2.meshMaterial = meshMaterial;\n    _this2.update();\n    return _this2;\n  }\n  _createClass(MeshBVHVisualizer, [{\n    key: \"color\",\n    get: function get() {\n      return this.edgeMaterial.color;\n    }\n  }, {\n    key: \"opacity\",\n    get: function get() {\n      return this.edgeMaterial.opacity;\n    },\n    set: function set(v) {\n      this.edgeMaterial.opacity = v;\n      this.meshMaterial.opacity = v;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var bvh = this.mesh.geometry.boundsTree;\n      var totalRoots = bvh ? bvh._roots.length : 0;\n      while (this._roots.length > totalRoots) {\n        var root = this._roots.pop();\n        root.geometry.dispose();\n        this.remove(root);\n      }\n      for (var i = 0; i < totalRoots; i++) {\n        if (i >= this._roots.length) {\n          var _root2 = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n          this.add(_root2);\n          this._roots.push(_root2);\n        }\n        var _root = this._roots[i];\n        _root.depth = this.depth;\n        _root.mesh = this.mesh;\n        _root.displayParents = this.displayParents;\n        _root.displayEdges = this.displayEdges;\n        _root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n        _root.update();\n      }\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld() {\n      var _get2;\n      this.position.copy(this.mesh.position);\n      this.rotation.copy(this.mesh.rotation);\n      this.scale.copy(this.mesh.scale);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_get2 = _get(_getPrototypeOf(MeshBVHVisualizer.prototype), \"updateMatrixWorld\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.depth = source.depth;\n      this.mesh = source.mesh;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MeshBVHVisualizer(this.mesh, this.depth);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.edgeMaterial.dispose();\n      this.meshMaterial.dispose();\n      var children = this.children;\n      for (var i = 0, l = children.length; i < l; i++) {\n        children[i].geometry.dispose();\n      }\n    }\n  }]);\n  return MeshBVHVisualizer;\n}(Group);\nexport { MeshBVHVisualizer };","map":{"version":3,"names":["LineBasicMaterial","BufferAttribute","Box3","Group","MeshBasicMaterial","Object3D","BufferGeometry","arrayToBox","boundingBox","MeshBVHRootVisualizer","mesh","material","depth","group","geometry","name","displayParents","displayEdges","_group","boundsTree","dispose","visible","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","min","max","x","xVal","y","yVal","z","zVal","indexArray","indices","Uint8Array","length","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","setAttribute","MeshBVHVisualizer","_roots","edgeMaterial","color","transparent","opacity","depthWrite","meshMaterial","update","v","bvh","totalRoots","root","pop","remove","add","push","position","copy","rotation","scale","args","source","children","l"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js"],"sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootVisualizer extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tconst root = this._roots.pop();\r\n\t\t\troot.geometry.dispose();\r\n\t\t\tthis.remove( root );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.depth = this.depth;\r\n\t\t\troot.mesh = this.mesh;\r\n\t\t\troot.displayParents = this.displayParents;\r\n\t\t\troot.displayEdges = this.displayEdges;\r\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { MeshBVHVisualizer };\r\n"],"mappings":";;;;;;AAAA,SAASA,iBAAiB,EAAEC,eAAe,EAAEC,IAAI,EAAEC,KAAK,EAAEC,iBAAiB,EAAEC,QAAQ,EAAEC,cAAc,QAAQ,OAAO;AACpH,SAASC,UAAU,QAAQ,+BAA+B;AAE1D,IAAMC,WAAW,GAAG,eAAgB,IAAIN,IAAI,EAAE;AAAC,IACzCO,qBAAqB;EAAA;EAAA;EAoB1B,+BAAaC,IAAI,EAAEC,QAAQ,EAA0B;IAAA;IAAA,IAAxBC,KAAK,uEAAG,EAAE;IAAA,IAAEC,KAAK,uEAAG,CAAC;IAAA;IAEjD;IAEA,MAAKF,QAAQ,GAAGA,QAAQ;IACxB,MAAKG,QAAQ,GAAG,IAAIR,cAAc,EAAE;IACpC,MAAKS,IAAI,GAAG,uBAAuB;IACnC,MAAKH,KAAK,GAAGA,KAAK;IAClB,MAAKI,cAAc,GAAG,KAAK;IAC3B,MAAKN,IAAI,GAAGA,IAAI;IAChB,MAAKO,YAAY,GAAG,IAAI;IACxB,MAAKC,MAAM,GAAGL,KAAK;IAAC;EAErB;EAAC;IAAA;IAAA,KA/BD,eAAa;MAEZ,OAAO,CAAE,IAAI,CAACI,YAAY;IAE3B;EAAC;IAAA;IAAA,KAED,eAAqB;MAEpB,OAAO,IAAI,CAACA,YAAY;IAEzB;EAAC;IAAA;IAAA,KAED,eAAa;MAEZ,OAAO,IAAI,CAACA,YAAY;IAEzB;EAAC;IAAA;IAAA,OAiBD,mBAAU,CAAC;EAAC;IAAA;IAAA,OAEZ,kBAAS;MAER,IAAMH,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC9B,IAAMK,UAAU,GAAG,IAAI,CAACT,IAAI,CAACI,QAAQ,CAACK,UAAU;MAChD,IAAMN,KAAK,GAAG,IAAI,CAACK,MAAM;MACzBJ,QAAQ,CAACM,OAAO,EAAE;MAClB,IAAI,CAACC,OAAO,GAAG,KAAK;MACpB,IAAKF,UAAU,EAAG;QAEjB;QACA,IAAMG,WAAW,GAAG,IAAI,CAACV,KAAK,GAAG,CAAC;QAClC,IAAMI,cAAc,GAAG,IAAI,CAACA,cAAc;QAC1C,IAAIO,WAAW,GAAG,CAAC;QACnBJ,UAAU,CAACK,QAAQ,CAAE,UAAEZ,KAAK,EAAEa,MAAM,EAAM;UAEzC,IAAKb,KAAK,KAAKU,WAAW,IAAIG,MAAM,EAAG;YAEtCF,WAAW,EAAG;YACd,OAAO,IAAI;UAEZ,CAAC,MAAM,IAAKP,cAAc,EAAG;YAE5BO,WAAW,EAAG;UAEf;QAED,CAAC,EAAEV,KAAK,CAAE;;QAEV;QACA,IAAIa,QAAQ,GAAG,CAAC;QAChB,IAAMC,aAAa,GAAG,IAAIC,YAAY,CAAE,CAAC,GAAG,CAAC,GAAGL,WAAW,CAAE;QAC7DJ,UAAU,CAACK,QAAQ,CAAE,UAAEZ,KAAK,EAAEa,MAAM,EAAEI,YAAY,EAAM;UAEvD,IAAMC,SAAS,GAAGlB,KAAK,KAAKU,WAAW,IAAIG,MAAM;UACjD,IAAKK,SAAS,IAAId,cAAc,EAAG;YAElCT,UAAU,CAAE,CAAC,EAAEsB,YAAY,EAAErB,WAAW,CAAE;YAE1C,IAAQuB,GAAG,GAAUvB,WAAW,CAAxBuB,GAAG;cAAEC,GAAG,GAAKxB,WAAW,CAAnBwB,GAAG;YAChB,KAAM,IAAIC,CAAC,GAAG,CAAE,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAG;cAEnC,IAAMC,IAAI,GAAGD,CAAC,GAAG,CAAC,GAAGF,GAAG,CAACE,CAAC,GAAGD,GAAG,CAACC,CAAC;cAClC,KAAM,IAAIE,CAAC,GAAG,CAAE,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAG;gBAEnC,IAAMC,IAAI,GAAGD,CAAC,GAAG,CAAC,GAAGJ,GAAG,CAACI,CAAC,GAAGH,GAAG,CAACG,CAAC;gBAClC,KAAM,IAAIE,CAAC,GAAG,CAAE,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAG;kBAEnC,IAAMC,IAAI,GAAGD,CAAC,GAAG,CAAC,GAAGN,GAAG,CAACM,CAAC,GAAGL,GAAG,CAACK,CAAC;kBAClCV,aAAa,CAAED,QAAQ,GAAG,CAAC,CAAE,GAAGQ,IAAI;kBACpCP,aAAa,CAAED,QAAQ,GAAG,CAAC,CAAE,GAAGU,IAAI;kBACpCT,aAAa,CAAED,QAAQ,GAAG,CAAC,CAAE,GAAGY,IAAI;kBAEpCZ,QAAQ,IAAI,CAAC;gBAEd;cAED;YAED;YAEA,OAAOI,SAAS;UAEjB;QAED,CAAC,EAAEjB,KAAK,CAAE;QAEV,IAAI0B,UAAU;QACd,IAAIC,OAAO;QACX,IAAK,IAAI,CAACvB,YAAY,EAAG;UAExB;UACAuB,OAAO,GAAG,IAAIC,UAAU,CAAE;UACzB;UACA,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC;UAEJ;UACA,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC;UAEJ;UACA,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,CACJ,CAAE;QAEJ,CAAC,MAAM;UAEND,OAAO,GAAG,IAAIC,UAAU,CAAE;UAEzB;UACA,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC,EAEP,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC;UAEP;UACA,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC,EAEP,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC;UAEP;UACA,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC,EAEP,CAAC,EAAE,CAAC,EAAE,CAAC,EACP,CAAC,EAAE,CAAC,EAAE,CAAC,CAEP,CAAE;QAEJ;QAEA,IAAKd,aAAa,CAACe,MAAM,GAAG,KAAK,EAAG;UAEnCH,UAAU,GAAG,IAAII,WAAW,CAAEH,OAAO,CAACE,MAAM,GAAGnB,WAAW,CAAE;QAE7D,CAAC,MAAM;UAENgB,UAAU,GAAG,IAAIK,WAAW,CAAEJ,OAAO,CAACE,MAAM,GAAGnB,WAAW,CAAE;QAE7D;QAEA,IAAMsB,WAAW,GAAGL,OAAO,CAACE,MAAM;QAClC,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,WAAW,EAAEuB,CAAC,EAAG,EAAG;UAExC,IAAMC,SAAS,GAAGD,CAAC,GAAG,CAAC;UACvB,IAAME,WAAW,GAAGF,CAAC,GAAGD,WAAW;UACnC,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAG,EAAG;YAExCV,UAAU,CAAES,WAAW,GAAGC,CAAC,CAAE,GAAGF,SAAS,GAAGP,OAAO,CAAES,CAAC,CAAE;UAEzD;QAED;;QAEA;QACAnC,QAAQ,CAACoC,QAAQ,CAChB,IAAIjD,eAAe,CAAEsC,UAAU,EAAE,CAAC,EAAE,KAAK,CAAE,CAC3C;QACDzB,QAAQ,CAACqC,YAAY,CACpB,UAAU,EACV,IAAIlD,eAAe,CAAE0B,aAAa,EAAE,CAAC,EAAE,KAAK,CAAE,CAC9C;QACD,IAAI,CAACN,OAAO,GAAG,IAAI;MAEpB;IAED;EAAC;EAAA;AAAA,EAhMkChB,QAAQ;AAAA,IAoMtC+C,iBAAiB;EAAA;EAAA;EAqBtB,2BAAa1C,IAAI,EAAe;IAAA;IAAA,IAAbE,KAAK,uEAAG,EAAE;IAAA;IAE5B;IAEA,OAAKG,IAAI,GAAG,mBAAmB;IAC/B,OAAKH,KAAK,GAAGA,KAAK;IAClB,OAAKF,IAAI,GAAGA,IAAI;IAChB,OAAKM,cAAc,GAAG,KAAK;IAC3B,OAAKC,YAAY,GAAG,IAAI;IACxB,OAAKoC,MAAM,GAAG,EAAE;IAEhB,IAAMC,YAAY,GAAG,IAAItD,iBAAiB,CAAE;MAC3CuD,KAAK,EAAE,QAAQ;MACfC,WAAW,EAAE,IAAI;MACjBC,OAAO,EAAE,GAAG;MACZC,UAAU,EAAE;IACb,CAAC,CAAE;IAEH,IAAMC,YAAY,GAAG,IAAIvD,iBAAiB,CAAE;MAC3CmD,KAAK,EAAE,QAAQ;MACfC,WAAW,EAAE,IAAI;MACjBC,OAAO,EAAE,GAAG;MACZC,UAAU,EAAE;IACb,CAAC,CAAE;IAEHC,YAAY,CAACJ,KAAK,GAAGD,YAAY,CAACC,KAAK;IAEvC,OAAKD,YAAY,GAAGA,YAAY;IAChC,OAAKK,YAAY,GAAGA,YAAY;IAEhC,OAAKC,MAAM,EAAE;IAAC;EAEf;EAAC;IAAA;IAAA,KAnDD,eAAY;MAEX,OAAO,IAAI,CAACN,YAAY,CAACC,KAAK;IAE/B;EAAC;IAAA;IAAA,KAED,eAAc;MAEb,OAAO,IAAI,CAACD,YAAY,CAACG,OAAO;IAEjC,CAAC;IAAA,KAED,aAAaI,CAAC,EAAG;MAEhB,IAAI,CAACP,YAAY,CAACG,OAAO,GAAGI,CAAC;MAC7B,IAAI,CAACF,YAAY,CAACF,OAAO,GAAGI,CAAC;IAE9B;EAAC;IAAA;IAAA,OAoCD,kBAAS;MAER,IAAMC,GAAG,GAAG,IAAI,CAACpD,IAAI,CAACI,QAAQ,CAACK,UAAU;MACzC,IAAM4C,UAAU,GAAGD,GAAG,GAAGA,GAAG,CAACT,MAAM,CAACX,MAAM,GAAG,CAAC;MAC9C,OAAQ,IAAI,CAACW,MAAM,CAACX,MAAM,GAAGqB,UAAU,EAAG;QAEzC,IAAMC,IAAI,GAAG,IAAI,CAACX,MAAM,CAACY,GAAG,EAAE;QAC9BD,IAAI,CAAClD,QAAQ,CAACM,OAAO,EAAE;QACvB,IAAI,CAAC8C,MAAM,CAAEF,IAAI,CAAE;MAEpB;MAEA,KAAM,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,UAAU,EAAEjB,CAAC,EAAG,EAAG;QAEvC,IAAKA,CAAC,IAAI,IAAI,CAACO,MAAM,CAACX,MAAM,EAAG;UAE9B,IAAMsB,MAAI,GAAG,IAAIvD,qBAAqB,CAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC4C,YAAY,EAAE,IAAI,CAAC1C,KAAK,EAAEkC,CAAC,CAAE;UACrF,IAAI,CAACqB,GAAG,CAAEH,MAAI,CAAE;UAChB,IAAI,CAACX,MAAM,CAACe,IAAI,CAAEJ,MAAI,CAAE;QAEzB;QAEA,IAAMA,KAAI,GAAG,IAAI,CAACX,MAAM,CAAEP,CAAC,CAAE;QAC7BkB,KAAI,CAACpD,KAAK,GAAG,IAAI,CAACA,KAAK;QACvBoD,KAAI,CAACtD,IAAI,GAAG,IAAI,CAACA,IAAI;QACrBsD,KAAI,CAAChD,cAAc,GAAG,IAAI,CAACA,cAAc;QACzCgD,KAAI,CAAC/C,YAAY,GAAG,IAAI,CAACA,YAAY;QACrC+C,KAAI,CAACrD,QAAQ,GAAG,IAAI,CAACM,YAAY,GAAG,IAAI,CAACqC,YAAY,GAAG,IAAI,CAACK,YAAY;QACzEK,KAAI,CAACJ,MAAM,EAAE;MAEd;IAED;EAAC;IAAA;IAAA,OAED,6BAA6B;MAAA;MAE5B,IAAI,CAACS,QAAQ,CAACC,IAAI,CAAE,IAAI,CAAC5D,IAAI,CAAC2D,QAAQ,CAAE;MACxC,IAAI,CAACE,QAAQ,CAACD,IAAI,CAAE,IAAI,CAAC5D,IAAI,CAAC6D,QAAQ,CAAE;MACxC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAE,IAAI,CAAC5D,IAAI,CAAC8D,KAAK,CAAE;MAAC,kCAJdC,IAAI;QAAJA,IAAI;MAAA;MAMzB,wHAA4BA,IAAI;IAEjC;EAAC;IAAA;IAAA,OAED,cAAMC,MAAM,EAAG;MAEd,IAAI,CAAC9D,KAAK,GAAG8D,MAAM,CAAC9D,KAAK;MACzB,IAAI,CAACF,IAAI,GAAGgE,MAAM,CAAChE,IAAI;IAExB;EAAC;IAAA;IAAA,OAED,iBAAQ;MAEP,OAAO,IAAI0C,iBAAiB,CAAE,IAAI,CAAC1C,IAAI,EAAE,IAAI,CAACE,KAAK,CAAE;IAEtD;EAAC;IAAA;IAAA,OAED,mBAAU;MAET,IAAI,CAAC0C,YAAY,CAAClC,OAAO,EAAE;MAC3B,IAAI,CAACuC,YAAY,CAACvC,OAAO,EAAE;MAE3B,IAAMuD,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC9B,KAAM,IAAI7B,CAAC,GAAG,CAAC,EAAE8B,CAAC,GAAGD,QAAQ,CAACjC,MAAM,EAAEI,CAAC,GAAG8B,CAAC,EAAE9B,CAAC,EAAG,EAAG;QAEnD6B,QAAQ,CAAE7B,CAAC,CAAE,CAAChC,QAAQ,CAACM,OAAO,EAAE;MAEjC;IAED;EAAC;EAAA;AAAA,EA5H8BjB,KAAK;AAiIrC,SAASiD,iBAAiB"},"metadata":{},"sourceType":"module"}