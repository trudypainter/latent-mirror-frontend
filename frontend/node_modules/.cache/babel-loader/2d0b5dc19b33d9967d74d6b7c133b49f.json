{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\nvar cb = new Vector3(),\n  ab = new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  var k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nvar Vertex = /*#__PURE__*/function () {\n  function Vertex(v, id) {\n    _classCallCheck(this, Vertex);\n    _defineProperty(this, \"position\", void 0);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"faces\", void 0);\n    _defineProperty(this, \"neighbors\", void 0);\n    _defineProperty(this, \"collapseCost\", void 0);\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n    _defineProperty(this, \"minCost\", 0);\n    _defineProperty(this, \"totalCost\", 0);\n    _defineProperty(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n  _createClass(Vertex, [{\n    key: \"addUniqueNeighbor\",\n    value: function addUniqueNeighbor(vertex) {\n      pushIfUnique(this.neighbors, vertex);\n    }\n  }, {\n    key: \"removeIfNonNeighbor\",\n    value: function removeIfNonNeighbor(n) {\n      var neighbors = this.neighbors;\n      var faces = this.faces;\n      var offset = neighbors.indexOf(n);\n      if (offset === -1) return;\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].hasVertex(n)) return;\n      }\n      neighbors.splice(offset, 1);\n    }\n  }]);\n  return Vertex;\n}(); // we use a triangle class to represent structure of face slightly differently\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle(v1, v2, v3, a, b, c) {\n    _classCallCheck(this, Triangle);\n    _defineProperty(this, \"a\", void 0);\n    _defineProperty(this, \"b\", void 0);\n    _defineProperty(this, \"c\", void 0);\n    _defineProperty(this, \"v1\", void 0);\n    _defineProperty(this, \"v2\", void 0);\n    _defineProperty(this, \"v3\", void 0);\n    _defineProperty(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  _createClass(Triangle, [{\n    key: \"computeNormal\",\n    value: function computeNormal() {\n      var vA = this.v1.position;\n      var vB = this.v2.position;\n      var vC = this.v3.position;\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      this.normal.copy(cb);\n    }\n  }, {\n    key: \"hasVertex\",\n    value: function hasVertex(v) {\n      return v === this.v1 || v === this.v2 || v === this.v3;\n    }\n  }, {\n    key: \"replaceVertex\",\n    value: function replaceVertex(oldv, newv) {\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n      removeFromArray(oldv.faces, this);\n      newv.faces.push(this);\n      oldv.removeIfNonNeighbor(this.v1);\n      this.v1.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v2);\n      this.v2.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v3);\n      this.v3.removeIfNonNeighbor(oldv);\n      this.v1.addUniqueNeighbor(this.v2);\n      this.v1.addUniqueNeighbor(this.v3);\n      this.v2.addUniqueNeighbor(this.v1);\n      this.v2.addUniqueNeighbor(this.v3);\n      this.v3.addUniqueNeighbor(this.v1);\n      this.v3.addUniqueNeighbor(this.v2);\n      this.computeNormal();\n    }\n  }]);\n  return Triangle;\n}(); /**\n      *\tSimplification Geometry Modifier\n      *    - based on code and technique\n      *\t  - by Stan Melax in 1998\n      *\t  - Progressive Mesh type Polygon Reduction Algorithm\n      *    - http://www.melax.com/polychop/\n      */\nvar SimplifyModifier = /*#__PURE__*/function () {\n  function SimplifyModifier() {\n    var _this = this;\n    _classCallCheck(this, SimplifyModifier);\n    _defineProperty(this, \"computeEdgeCollapseCost\", function (u, v) {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      var edgelength = v.position.distanceTo(u.position);\n      var curvature = 0;\n      var sideFaces = [];\n      var i,\n        il = u.faces.length,\n        face,\n        sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n      for (i = 0; i < il; i++) {\n        var minCurvature = 1;\n        face = u.faces[i];\n        for (var j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          var dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n      var borders = 0;\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n      var amt = edgelength * curvature + borders;\n      return amt;\n    });\n    _defineProperty(this, \"computeEdgeCostAtVertex\", function (v) {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (var i = 0; i < v.neighbors.length; i++) {\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", function (f, faces) {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      var vs = [f.v1, f.v2, f.v3];\n      var v1, v2;\n      for (var i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    _defineProperty(this, \"collapse\", function (vertices, faces, u, v) {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        _this.removeVertex(u, vertices);\n        return;\n      }\n      var i;\n      var tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          _this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      _this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    _defineProperty(this, \"minimumCostEdge\", function (vertices) {\n      // O(n * n) approach. TODO optimize this\n      var least = vertices[0];\n      for (var i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    _defineProperty(this, \"modify\", function (geometry, count) {\n      geometry = geometry.clone();\n      var attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (var name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      var vertices = [];\n      var faces = []; // add vertices\n\n      var positionAttribute = geometry.getAttribute('position');\n      for (var i = 0; i < positionAttribute.count; i++) {\n        var v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        var vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n      var geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\n          var a = geomIndex.getX(_i);\n          var b = geomIndex.getX(_i + 1);\n          var c = geomIndex.getX(_i + 2);\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\n          var _a = _i2;\n          var _b = _i2 + 1;\n          var _c = _i2 + 2;\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\n          faces.push(_triangle);\n        }\n      } // compute all edge collapse costs\n\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\n      }\n      var nextVertex;\n      var z = count;\n      while (z--) {\n        nextVertex = _this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n      var simplifiedGeometry = new BufferGeometry();\n      var position = [];\n      var index = []; //\n\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\n        var _vertex = vertices[_i4].position;\n        position.push(_vertex.x, _vertex.y, _vertex.z);\n      } //\n\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\n        var face = faces[_i5];\n        var _a2 = vertices.indexOf(face.v1);\n        var _b2 = vertices.indexOf(face.v2);\n        var _c2 = vertices.indexOf(face.v3);\n        index.push(_a2, _b2, _c2);\n      } //\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  _createClass(SimplifyModifier, [{\n    key: \"removeVertex\",\n    value: function removeVertex(v, vertices) {\n      console.assert(v.faces.length === 0);\n      while (v.neighbors.length) {\n        var n = v.neighbors.pop();\n        removeFromArray(n.neighbors, v);\n      }\n      removeFromArray(vertices, v);\n    }\n  }]);\n  return SimplifyModifier;\n}();\nexport { SimplifyModifier };","map":{"version":3,"names":["_defineProperty","Vector3","BufferGeometry","Float32BufferAttribute","mergeVertices","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","v","id","position","faces","neighbors","collapseCost","collapseNeighbor","vertex","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","addUniqueNeighbor","vA","vB","vC","subVectors","cross","normalize","normal","copy","oldv","newv","removeIfNonNeighbor","SimplifyModifier","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","replaceVertex","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","index","x","y","setAttribute","setIndex","assert","pop"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}