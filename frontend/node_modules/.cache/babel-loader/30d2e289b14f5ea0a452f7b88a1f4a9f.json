{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectMethods = exports.LooksAhead = void 0;\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */function () {\n  function LooksAhead() {}\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\") ? config.maxLookahead // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookAheadFuncsCache = new Map();\n  };\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n    (0, forEach_1.default)(rules, function (currRule) {\n      _this.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n        var _a = collectMethods(currRule),\n          alternation = _a.alternation,\n          repetition = _a.repetition,\n          option = _a.option,\n          repetitionMandatory = _a.repetitionMandatory,\n          repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n          repetitionWithSeparator = _a.repetitionWithSeparator;\n        (0, forEach_1.default)(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          _this.TRACE_INIT(\"\".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function () {\n            var laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        (0, forEach_1.default)(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n      });\n    });\n  };\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n    this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n      var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      _this.setLaFuncCache(key, laFunc);\n    });\n  };\n  LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);\n  };\n  LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n  };\n  // this actually returns a number, but it is always used as a string (object prop key)\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n  };\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n  return LooksAhead;\n}();\nexports.LooksAhead = LooksAhead;\nvar DslMethodsCollectorVisitor = /** @class */function (_super) {\n  __extends(DslMethodsCollectorVisitor, _super);\n  function DslMethodsCollectorVisitor() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n    return _this;\n  }\n  DslMethodsCollectorVisitor.prototype.reset = function () {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  };\n  DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n    this.dslMethods.option.push(option);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n    this.dslMethods.repetition.push(many);\n  };\n  DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n    this.dslMethods.alternation.push(or);\n  };\n  return DslMethodsCollectorVisitor;\n}(gast_1.GAstVisitor);\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  var dslMethods = collectorVisitor.dslMethods;\n  // avoid uncleaned references\n  collectorVisitor.reset();\n  return dslMethods;\n}\nexports.collectMethods = collectMethods;","map":{"version":3,"mappings":"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","names":["LooksAhead","config","dynamicTokensEnabled","parser_1","maxLookahead","lookAheadFuncsCache","Map","rules","currRule","_this","TRACE_INIT","name","collectMethods","alternation","repetition","option","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","currProd","prodIdx","idx","laFunc","hasPredicates","lookAheadBuilderForAlternatives","key","fullRuleNameToShort","keys_1","setLaFuncCache","computeLookaheadFunc","lookahead_1","REPETITION","OPTION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","rule","prodOccurrence","prodKey","prodType","prodMaxLookahead","dslMethodName","lookAheadBuilderForOptional","alt","tokenMatcher","alts","dslMethodIdx","occurrence","currRuleShortName","getLastExplicitRuleShortName","get","value","set","exports","__extends","DslMethodsCollectorVisitor","dslMethods","push","manySep","atLeastOne","atLeastOneSep","many","or","gast_1","collectorVisitor","reset","accept"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts"],"sourcesContent":["import {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport {\n  DEFAULT_PARSER_CONFIG,\n  LookAheadSequence,\n  TokenMatcher\n} from \"../parser\"\nimport { IOrAlt, IParserConfig } from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    this.lookAheadFuncsCache = new Map()\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = buildLookaheadFuncForOr(\n              currProd.idx,\n              currRule,\n              currProd.maxLookahead || this.maxLookahead,\n              currProd.hasPredicates,\n              this.dynamicTokensEnabled,\n              this.lookAheadBuilderForAlternatives\n            )\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            PROD_TYPE.REPETITION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            PROD_TYPE.OPTION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            PROD_TYPE.REPETITION_MANDATORY,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            PROD_TYPE.REPETITION_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: PROD_TYPE,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = buildLookaheadFuncForOptionalProd(\n          prodOccurrence,\n          rule,\n          prodMaxLookahead || this.maxLookahead,\n          this.dynamicTokensEnabled,\n          prodType,\n          this.lookAheadBuilderForOptional\n        )\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  lookAheadBuilderForOptional(\n    this: MixedInParser,\n    alt: LookAheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): () => boolean {\n    return buildSingleAlternativeLookaheadFunction(\n      alt,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  lookAheadBuilderForAlternatives(\n    this: MixedInParser,\n    alts: LookAheadSequence[],\n    hasPredicates: boolean,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): (orAlts: IOrAlt<any>[]) => number | undefined {\n    return buildAlternativesLookAheadFunc(\n      alts,\n      hasPredicates,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[]\n    alternation: Alternation[]\n    repetition: Repetition[]\n    repetitionWithSeparator: RepetitionWithSeparator[]\n    repetitionMandatory: RepetitionMandatory[]\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(rule: Rule): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n"]},"metadata":{},"sourceType":"script"}