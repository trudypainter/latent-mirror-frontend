{"ast":null,"code":"import _toConsumableArray from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\nvar _positionVector = /*@__PURE__*/new Vector3();\nvar _normalVector = /*@__PURE__*/new Vector3();\nvar _tangentVector = /*@__PURE__*/new Vector3();\nvar _tangentVector4 = /*@__PURE__*/new Vector4();\nvar _morphVector = /*@__PURE__*/new Vector3();\nvar _temp = /*@__PURE__*/new Vector3();\nvar _skinIndex = /*@__PURE__*/new Vector4();\nvar _skinWeight = /*@__PURE__*/new Vector4();\nvar _matrix = /*@__PURE__*/new Matrix4();\nvar _boneMatrix = /*@__PURE__*/new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n  var sameCount = attr1.count === attr2.count;\n  var sameNormalized = attr1.normalized === attr2.normalized;\n  var sameType = attr1.array.constructor === attr2.array.constructor;\n  var sameItemSize = attr1.itemSize === attr2.itemSize;\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone(attr) {\n  var countOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var cons = attr.array.constructor;\n  var normalized = attr.normalized;\n  var itemSize = attr.itemSize;\n  var count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents(attr, target) {\n  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (attr.isInterleavedBufferAttribute) {\n    var itemSize = attr.itemSize;\n    for (var i = 0, l = attr.count; i < l; i++) {\n      var io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    var array = target.array;\n    var cons = array.constructor;\n    var byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    var temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix(target, matrix, scale) {\n  var targetArray = target.elements;\n  var matrixArray = matrix.elements;\n  for (var i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform(mesh, index, target) {\n  var skeleton = mesh.skeleton;\n  var geometry = mesh.geometry;\n  var bones = skeleton.bones;\n  var boneInverses = skeleton.boneInverses;\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n  _matrix.elements.fill(0);\n  for (var i = 0; i < 4; i++) {\n    var weight = _skinWeight.getComponent(i);\n    if (weight !== 0) {\n      var boneIndex = _skinIndex.getComponent(i);\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n  target.transformDirection(_matrix);\n  return target;\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n  for (var j = 0, jl = morphData.length; j < jl; j++) {\n    var influence = morphInfluences[j];\n    var morphAttribute = morphData[j];\n    if (influence === 0) continue;\n    _temp.fromBufferAttribute(morphAttribute, i);\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n  target.add(_morphVector);\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in plac\nfunction mergeBufferGeometries(geometries) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    useGroups: false,\n    updateIndex: false\n  };\n  var targetGeometry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BufferGeometry();\n  var isIndexed = geometries[0].index !== null;\n  var useGroups = options.useGroups,\n    updateIndex = options.updateIndex;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var attributes = {};\n  var offset = 0;\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    }\n\n    // gather attributes, exit early if they're different\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n    if (useGroups) {\n      var count = void 0;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n  if (isIndexed) {\n    var forceUpateIndex = false;\n    if (!targetGeometry.index) {\n      var indexCount = 0;\n      for (var _i = 0; _i < geometries.length; ++_i) {\n        indexCount += geometries[_i].index.count;\n      }\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpateIndex = true;\n    }\n    if (updateIndex || forceUpateIndex) {\n      var targetIndex = targetGeometry.index;\n      var targetOffset = 0;\n      var indexOffset = 0;\n      for (var _i2 = 0; _i2 < geometries.length; ++_i2) {\n        var _geometry = geometries[_i2];\n        var index = _geometry.index;\n        for (var j = 0; j < index.count; ++j) {\n          targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n          targetOffset++;\n        }\n        indexOffset += _geometry.attributes.position.count;\n      }\n    }\n  }\n\n  // merge attributes\n  for (var _name in attributes) {\n    var attrList = attributes[_name];\n    if (!(_name in targetGeometry.attributes)) {\n      var _count = 0;\n      for (var key in attrList) {\n        _count += attrList[key].count;\n      }\n      targetGeometry.setAttribute(_name, createAttributeClone(attributes[_name][0], _count));\n    }\n    var targetAttribute = targetGeometry.attributes[_name];\n    var _offset = 0;\n    for (var _key in attrList) {\n      var attr = attrList[_key];\n      copyAttributeContents(attr, targetAttribute, _offset);\n      _offset += attr.count;\n    }\n  }\n  return targetGeometry;\n}\nexport var StaticGeometryGenerator = /*#__PURE__*/function () {\n  function StaticGeometryGenerator(meshes) {\n    _classCallCheck(this, StaticGeometryGenerator);\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    var finalMeshes = [];\n    meshes.forEach(function (object) {\n      object.traverse(function (c) {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(function () {\n      return new BufferGeometry();\n    });\n  }\n  _createClass(StaticGeometryGenerator, [{\n    key: \"getMaterials\",\n    value: function getMaterials() {\n      var materials = [];\n      this.meshes.forEach(function (mesh) {\n        if (Array.isArray(mesh.material)) {\n          materials.push.apply(materials, _toConsumableArray(mesh.material));\n        } else {\n          materials.push(mesh.material);\n        }\n      });\n      return materials;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      var targetGeometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n      var meshes = this.meshes,\n        useGroups = this.useGroups,\n        _intermediateGeometry = this._intermediateGeometry;\n      for (var i = 0, l = meshes.length; i < l; i++) {\n        var mesh = meshes[i];\n        var geom = _intermediateGeometry[i];\n        this._convertToStaticGeometry(mesh, geom);\n      }\n      mergeBufferGeometries(_intermediateGeometry, {\n        useGroups: useGroups\n      }, targetGeometry);\n      for (var key in targetGeometry.attributes) {\n        targetGeometry.attributes[key].needsUpdate = true;\n      }\n      return targetGeometry;\n    }\n  }, {\n    key: \"_convertToStaticGeometry\",\n    value: function _convertToStaticGeometry(mesh) {\n      var targetGeometry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BufferGeometry();\n      var geometry = mesh.geometry;\n      var applyWorldTransforms = this.applyWorldTransforms;\n      var includeNormal = this.attributes.includes('normal');\n      var includeTangent = this.attributes.includes('tangent');\n      var attributes = geometry.attributes;\n      var targetAttributes = targetGeometry.attributes;\n\n      // initialize the attributes if they don't exist\n      if (!targetGeometry.index) {\n        targetGeometry.index = geometry.index;\n      }\n      if (!targetAttributes.position) {\n        targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n      }\n      if (includeNormal && !targetAttributes.normal && attributes.normal) {\n        targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n      }\n      if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n        targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n      }\n\n      // ensure the attributes are consistent\n      validateAttributes(geometry.index, targetGeometry.index);\n      validateAttributes(attributes.position, targetAttributes.position);\n      if (includeNormal) {\n        validateAttributes(attributes.normal, targetAttributes.normal);\n      }\n      if (includeTangent) {\n        validateAttributes(attributes.tangent, targetAttributes.tangent);\n      }\n\n      // generate transformed vertex attribute data\n      var position = attributes.position;\n      var normal = includeNormal ? attributes.normal : null;\n      var tangent = includeTangent ? attributes.tangent : null;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphNormal = geometry.morphAttributes.normal;\n      var morphTangent = geometry.morphAttributes.tangent;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var morphInfluences = mesh.morphTargetInfluences;\n      var normalMatrix = new Matrix3();\n      normalMatrix.getNormalMatrix(mesh.matrixWorld);\n      for (var i = 0, l = attributes.position.count; i < l; i++) {\n        _positionVector.fromBufferAttribute(position, i);\n        if (normal) {\n          _normalVector.fromBufferAttribute(normal, i);\n        }\n        if (tangent) {\n          _tangentVector4.fromBufferAttribute(tangent, i);\n          _tangentVector.fromBufferAttribute(tangent, i);\n        }\n\n        // apply morph target transform\n        if (morphInfluences) {\n          if (morphPosition) {\n            applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n          }\n          if (morphNormal) {\n            applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n          }\n          if (morphTangent) {\n            applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n          }\n        }\n\n        // apply bone transform\n        if (mesh.isSkinnedMesh) {\n          mesh.boneTransform(i, _positionVector);\n          if (normal) {\n            boneNormalTransform(mesh, i, _normalVector);\n          }\n          if (tangent) {\n            boneNormalTransform(mesh, i, _tangentVector);\n          }\n        }\n\n        // update the vectors of the attributes\n        if (applyWorldTransforms) {\n          _positionVector.applyMatrix4(mesh.matrixWorld);\n        }\n        targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n        if (normal) {\n          if (applyWorldTransforms) {\n            _normalVector.applyNormalMatrix(normalMatrix);\n          }\n          targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n        }\n        if (tangent) {\n          if (applyWorldTransforms) {\n            _tangentVector.transformDirection(mesh.matrixWorld);\n          }\n          targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n        }\n      }\n\n      // copy other attributes over\n      for (var _i3 in this.attributes) {\n        var key = this.attributes[_i3];\n        if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n          continue;\n        }\n        if (!targetAttributes[key]) {\n          targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n        }\n        validateAttributes(attributes[key], targetAttributes[key]);\n        copyAttributeContents(attributes[key], targetAttributes[key]);\n      }\n      return targetGeometry;\n    }\n  }]);\n  return StaticGeometryGenerator;\n}();","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","Vector4","Matrix4","Matrix3","_positionVector","_normalVector","_tangentVector","_tangentVector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","Error","createAttributeClone","attr","countOverride","cons","copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","length","set","addScaledMatrix","matrix","scale","targetArray","elements","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","fromBufferAttribute","attributes","skinIndex","skinWeight","fill","weight","getComponent","boneIndex","multiplyMatrices","matrixWorld","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","mergeBufferGeometries","geometries","options","useGroups","updateIndex","targetGeometry","isIndexed","attributesUsed","Set","Object","keys","offset","attributesCount","name","has","undefined","push","size","position","addGroup","forceUpateIndex","indexCount","setIndex","Uint32Array","targetIndex","indexOffset","attrList","key","setAttribute","targetAttribute","StaticGeometryGenerator","meshes","Array","isArray","finalMeshes","forEach","object","traverse","c","isMesh","applyWorldTransforms","_intermediateGeometry","map","materials","material","geom","_convertToStaticGeometry","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","getNormalMatrix","isSkinnedMesh","boneTransform","applyMatrix4","setXYZ","x","y","z","applyNormalMatrix","setXYZW","w"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\r\n\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// Confirms that the two provided attributes are compatible\r\nfunction validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nfunction createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\tconst bones = skeleton.bones;\r\n\tconst boneInverses = skeleton.boneInverses;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\ttarget.transformDirection( _matrix );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in plac\r\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false }, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst { useGroups, updateIndex } = options;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst attributes = {};\r\n\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) {\r\n\r\n\t\t\t\tattributes[ name ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, count, i );\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet forceUpateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\tlet indexCount = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tindexCount += geometries[ i ].index.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\r\n\t\t\tforceUpateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateIndex || forceUpateIndex ) {\r\n\r\n\t\t\tconst targetIndex = targetGeometry.index;\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.index;\r\n\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\r\n\t\t\t\t\ttargetOffset ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindexOffset += geometry.attributes.position.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst attrList = attributes[ name ];\r\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\r\n\r\n\t\t\tlet count = 0;\r\n\t\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\t\tcount += attrList[ key ].count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\tconst attr = attrList[ key ];\r\n\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( meshes ) {\r\n\r\n\t\tif ( ! Array.isArray( meshes ) ) {\r\n\r\n\t\t\tmeshes = [ meshes ];\r\n\r\n\t\t}\r\n\r\n\t\tconst finalMeshes = [];\r\n\t\tmeshes.forEach( object => {\r\n\r\n\t\t\tobject.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isMesh ) {\r\n\r\n\t\t\t\t\tfinalMeshes.push( c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.meshes = finalMeshes;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\r\n\r\n\t}\r\n\r\n\tgetMaterials() {\r\n\r\n\t\tconst materials = [];\r\n\t\tthis.meshes.forEach( mesh => {\r\n\r\n\t\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\t\treturn materials;\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst { meshes, useGroups, _intermediateGeometry } = this;\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry[ i ];\r\n\t\t\tthis._convertToStaticGeometry( mesh, geom );\r\n\r\n\t\t}\r\n\r\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups }, targetGeometry );\r\n\t\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\r\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\r\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t\t// initialize the attributes if they don't exist\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\ttargetGeometry.index = geometry.index;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes.position ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t\t}\r\n\r\n\t\t// ensure the attributes are consistent\r\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\t\tif ( includeNormal ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t\t}\r\n\r\n\t\t// generate transformed vertex attribute data\r\n\t\tconst position = attributes.position;\r\n\t\tconst normal = includeNormal ? attributes.normal : null;\r\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\t\tconst morphPosition = geometry.morphAttributes.position;\r\n\t\tconst morphNormal = geometry.morphAttributes.normal;\r\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\t\tconst normalMatrix = new Matrix3();\r\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply morph target transform\r\n\t\t\tif ( morphInfluences ) {\r\n\r\n\t\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply bone transform\r\n\t\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\t\tmesh.boneTransform( i, _positionVector );\r\n\t\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the vectors of the attributes\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// copy other attributes over\r\n\t\tfor ( const i in this.attributes ) {\r\n\r\n\t\t\tconst key = this.attributes[ i ];\r\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}