{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\nvar _m1 = new Matrix4();\nvar _obj = new Object3D();\nvar _offset = new Vector3();\nvar Geometry = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(Geometry, _EventDispatcher);\n  var _super = _createSuper(Geometry);\n  function Geometry() {\n    var _this;\n    _classCallCheck(this, Geometry);\n    _this = _super.call(this);\n    _this.isGeometry = true;\n    _this.uuid = MathUtils.generateUUID();\n    _this.name = '';\n    _this.type = 'Geometry';\n    _this.vertices = [];\n    _this.colors = [];\n    _this.faces = [];\n    _this.faceVertexUvs = [[]];\n    _this.morphTargets = [];\n    _this.morphNormals = [];\n    _this.skinWeights = [];\n    _this.skinIndices = [];\n    _this.lineDistances = [];\n    _this.boundingBox = null;\n    _this.boundingSphere = null; // update flags\n\n    _this.elementsNeedUpdate = false;\n    _this.verticesNeedUpdate = false;\n    _this.uvsNeedUpdate = false;\n    _this.normalsNeedUpdate = false;\n    _this.colorsNeedUpdate = false;\n    _this.lineDistancesNeedUpdate = false;\n    _this.groupsNeedUpdate = false;\n    return _this;\n  }\n  _createClass(Geometry, [{\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var vertex = this.vertices[i];\n        vertex.applyMatrix4(matrix);\n      }\n      for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\n        var face = this.faces[_i];\n        face.normal.applyMatrix3(normalMatrix).normalize();\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n        }\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"rotateX\",\n    value: function rotateX(angle) {\n      // rotate geometry around world x-axis\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateY\",\n    value: function rotateY(angle) {\n      // rotate geometry around world y-axis\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateZ\",\n    value: function rotateZ(angle) {\n      // rotate geometry around world z-axis\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y, z) {\n      // translate geometry\n      _m1.makeTranslation(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(x, y, z) {\n      // scale geometry\n      _m1.makeScale(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n  }, {\n    key: \"fromBufferGeometry\",\n    value: function fromBufferGeometry(geometry) {\n      var scope = this;\n      var index = geometry.index !== null ? geometry.index : undefined;\n      var attributes = geometry.attributes;\n      if (attributes.position === undefined) {\n        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n        return this;\n      }\n      var position = attributes.position;\n      var normal = attributes.normal;\n      var color = attributes.color;\n      var uv = attributes.uv;\n      var uv2 = attributes.uv2;\n      if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n      for (var i = 0; i < position.count; i++) {\n        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n        if (color !== undefined) {\n          scope.colors.push(new Color().fromBufferAttribute(color, i));\n        }\n      }\n      function addFace(a, b, c, materialIndex) {\n        var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n        var vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n        scope.faces.push(face);\n        if (uv !== undefined) {\n          scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n        }\n        if (uv2 !== undefined) {\n          scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n        }\n      }\n      var groups = geometry.groups;\n      if (groups.length > 0) {\n        for (var _i2 = 0; _i2 < groups.length; _i2++) {\n          var group = groups[_i2];\n          var start = group.start;\n          var count = group.count;\n          for (var j = start, jl = start + count; j < jl; j += 3) {\n            if (index !== undefined) {\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n            } else {\n              addFace(j, j + 1, j + 2, group.materialIndex);\n            }\n          }\n        }\n      } else {\n        if (index !== undefined) {\n          for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\n            addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\n          }\n        } else {\n          for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\n            addFace(_i4, _i4 + 1, _i4 + 2);\n          }\n        }\n      }\n      this.computeFaceNormals();\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n      return this;\n    }\n  }, {\n    key: \"center\",\n    value: function center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      this.computeBoundingSphere();\n      var center = this.boundingSphere.center;\n      var radius = this.boundingSphere.radius;\n      var s = radius === 0 ? 1 : 1.0 / radius;\n      var matrix = new Matrix4();\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n      this.applyMatrix4(matrix);\n      return this;\n    }\n  }, {\n    key: \"computeFaceNormals\",\n    value: function computeFaceNormals() {\n      var cb = new Vector3(),\n        ab = new Vector3();\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vA = this.vertices[face.a];\n        var vB = this.vertices[face.b];\n        var vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n      }\n    }\n  }, {\n    key: \"computeVertexNormals\",\n    value: function computeVertexNormals() {\n      var areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var vertices = new Array(this.vertices.length);\n      for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v] = new Vector3();\n      }\n      if (areaWeighted) {\n        // vertex normals weighted by triangle areas\n        // http://www.iquilezles.org/www/articles/normals/normals.htm\n        var cb = new Vector3(),\n          ab = new Vector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n          var face = this.faces[f];\n          var vA = this.vertices[face.a];\n          var vB = this.vertices[face.b];\n          var vC = this.vertices[face.c];\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          vertices[face.a].add(cb);\n          vertices[face.b].add(cb);\n          vertices[face.c].add(cb);\n        }\n      } else {\n        this.computeFaceNormals();\n        for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\n          var _face = this.faces[_f];\n          vertices[_face.a].add(_face.normal);\n          vertices[_face.b].add(_face.normal);\n          vertices[_face.c].add(_face.normal);\n        }\n      }\n      for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\n        vertices[_v].normalize();\n      }\n      for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\n        var _face2 = this.faces[_f2];\n        var vertexNormals = _face2.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(vertices[_face2.a]);\n          vertexNormals[1].copy(vertices[_face2.b]);\n          vertexNormals[2].copy(vertices[_face2.c]);\n        } else {\n          vertexNormals[0] = vertices[_face2.a].clone();\n          vertexNormals[1] = vertices[_face2.b].clone();\n          vertexNormals[2] = vertices[_face2.c].clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeFlatVertexNormals\",\n    value: function computeFlatVertexNormals() {\n      this.computeFaceNormals();\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(face.normal);\n          vertexNormals[1].copy(face.normal);\n          vertexNormals[2].copy(face.normal);\n        } else {\n          vertexNormals[0] = face.normal.clone();\n          vertexNormals[1] = face.normal.clone();\n          vertexNormals[2] = face.normal.clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeMorphNormals\",\n    value: function computeMorphNormals() {\n      // save original normals\n      // - create temp variables on first access\n      //   otherwise just copy (for faster repeated calls)\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        if (!face.__originalFaceNormal) {\n          face.__originalFaceNormal = face.normal.clone();\n        } else {\n          face.__originalFaceNormal.copy(face.normal);\n        }\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n        for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n          if (!face.__originalVertexNormals[i]) {\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n          } else {\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n          }\n        }\n      } // use temp geometry to compute face and vertex normals for each morph\n\n      var tmpGeo = new Geometry();\n      tmpGeo.faces = this.faces;\n      for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\n        // create on first access\n        if (!this.morphNormals[_i5]) {\n          this.morphNormals[_i5] = {};\n          this.morphNormals[_i5].faceNormals = [];\n          this.morphNormals[_i5].vertexNormals = [];\n          var dstNormalsFace = this.morphNormals[_i5].faceNormals;\n          var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\n          for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\n            var faceNormal = new Vector3();\n            var vertexNormals = {\n              a: new Vector3(),\n              b: new Vector3(),\n              c: new Vector3()\n            };\n            dstNormalsFace.push(faceNormal);\n            dstNormalsVertex.push(vertexNormals);\n          }\n        }\n        var morphNormals = this.morphNormals[_i5]; // set vertices to morph target\n\n        tmpGeo.vertices = this.morphTargets[_i5].vertices; // compute morph normals\n\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals(); // store morph normals\n\n        for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\n          var _face3 = this.faces[_f4];\n          var _faceNormal = morphNormals.faceNormals[_f4];\n          var _vertexNormals = morphNormals.vertexNormals[_f4];\n          _faceNormal.copy(_face3.normal);\n          _vertexNormals.a.copy(_face3.vertexNormals[0]);\n          _vertexNormals.b.copy(_face3.vertexNormals[1]);\n          _vertexNormals.c.copy(_face3.vertexNormals[2]);\n        }\n      } // restore original normals\n\n      for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\n        var _face4 = this.faces[_f5];\n        _face4.normal = _face4.__originalFaceNormal;\n        _face4.vertexNormals = _face4.__originalVertexNormals;\n      }\n    }\n  }, {\n    key: \"computeBoundingBox\",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      this.boundingBox.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"computeBoundingSphere\",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      this.boundingSphere.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(geometry, matrix) {\n      var materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (!(geometry && geometry.isGeometry)) {\n        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n        return;\n      }\n      var normalMatrix;\n      var vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n      if (matrix !== undefined) {\n        normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      } // vertices\n\n      for (var i = 0, il = vertices2.length; i < il; i++) {\n        var vertex = vertices2[i];\n        var vertexCopy = vertex.clone();\n        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n        vertices1.push(vertexCopy);\n      } // colors\n\n      for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\n        colors1.push(colors2[_i6].clone());\n      } // faces\n\n      for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\n        var face = faces2[_i7];\n        var normal = void 0,\n          color = void 0;\n        var faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n        var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n        faceCopy.normal.copy(face.normal);\n        if (normalMatrix !== undefined) {\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n        }\n        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n          normal = faceVertexNormals[j].clone();\n          if (normalMatrix !== undefined) {\n            normal.applyMatrix3(normalMatrix).normalize();\n          }\n          faceCopy.vertexNormals.push(normal);\n        }\n        faceCopy.color.copy(face.color);\n        for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\n          color = faceVertexColors[_j];\n          faceCopy.vertexColors.push(color.clone());\n        }\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n        faces1.push(faceCopy);\n      } // uvs\n\n      for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\n        var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\n        if (this.faceVertexUvs[_i8] === undefined) this.faceVertexUvs[_i8] = [];\n        for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\n          var uvs2 = faceVertexUvs2[_j2],\n            uvsCopy = [];\n          for (var k = 0, kl = uvs2.length; k < kl; k++) {\n            uvsCopy.push(uvs2[k].clone());\n          }\n          this.faceVertexUvs[_i8].push(uvsCopy);\n        }\n      }\n    }\n  }, {\n    key: \"mergeMesh\",\n    value: function mergeMesh(mesh) {\n      if (!(mesh && mesh.isMesh)) {\n        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n        return;\n      }\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n      this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n  }, {\n    key: \"mergeVertices\",\n    value: function mergeVertices() {\n      var precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n      var unique = [],\n        changes = [];\n      var precision = Math.pow(10, precisionPoints);\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var v = this.vertices[i];\n        var key = \"\".concat(Math.round(v.x * precision), \"_\").concat(Math.round(v.y * precision), \"_\").concat(Math.round(v.z * precision));\n        if (verticesMap[key] === undefined) {\n          verticesMap[key] = i;\n          unique.push(this.vertices[i]);\n          changes[i] = unique.length - 1;\n        } else {\n          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n          changes[i] = changes[verticesMap[key]];\n        }\n      } // if faces are completely degenerate after merging vertices, we\n      // have to remove them from the geometry.\n\n      var faceIndicesToRemove = [];\n      for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\n        var face = this.faces[_i9];\n        face.a = changes[face.a];\n        face.b = changes[face.b];\n        face.c = changes[face.c];\n        var indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n        // we have to remove the face as nothing can be saved\n\n        for (var n = 0; n < 3; n++) {\n          if (indices[n] === indices[(n + 1) % 3]) {\n            faceIndicesToRemove.push(_i9);\n            break;\n          }\n        }\n      }\n      for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\n        var idx = faceIndicesToRemove[_i10];\n        this.faces.splice(idx, 1);\n        for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n          this.faceVertexUvs[j].splice(idx, 1);\n        }\n      } // Use unique set of vertices\n\n      var diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      this.vertices = [];\n      for (var i = 0, l = points.length; i < l; i++) {\n        var point = points[i];\n        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n      }\n      return this;\n    }\n  }, {\n    key: \"sortFacesByMaterialIndex\",\n    value: function sortFacesByMaterialIndex() {\n      var faces = this.faces;\n      var length = faces.length; // tag faces\n\n      for (var i = 0; i < length; i++) {\n        faces[i]._id = i;\n      } // sort faces\n\n      function materialIndexSort(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n      faces.sort(materialIndexSort); // sort uvs\n\n      var uvs1 = this.faceVertexUvs[0];\n      var uvs2 = this.faceVertexUvs[1];\n      var newUvs1, newUvs2;\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\n      for (var _i11 = 0; _i11 < length; _i11++) {\n        var id = faces[_i11]._id;\n        if (newUvs1) newUvs1.push(uvs1[id]);\n        if (newUvs2) newUvs2.push(uvs2[id]);\n      }\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: 'Geometry',\n          generator: 'Geometry.toJSON'\n        }\n      }; // standard Geometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== '') data.name = this.name;\n      if (this.parameters !== undefined) {\n        var parameters = this.parameters;\n        for (var key in parameters) {\n          if (parameters[key] !== undefined) data[key] = parameters[key];\n        }\n        return data;\n      }\n      var vertices = [];\n      for (var i = 0; i < this.vertices.length; i++) {\n        var vertex = this.vertices[i];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n      var faces = [];\n      var normals = [];\n      var normalsHash = {};\n      var colors = [];\n      var colorsHash = {};\n      var uvs = [];\n      var uvsHash = {};\n      for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\n        var face = this.faces[_i12];\n        var hasMaterial = true;\n        var hasFaceUv = false; // deprecated\n\n        var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== undefined;\n        var hasFaceNormal = face.normal.length() > 0;\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        var hasFaceVertexColor = face.vertexColors.length > 0;\n        var faceType = 0;\n        faceType = setBit(faceType, 0, 0); // isQuad\n\n        faceType = setBit(faceType, 1, hasMaterial);\n        faceType = setBit(faceType, 2, hasFaceUv);\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\n        faceType = setBit(faceType, 4, hasFaceNormal);\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\n        faceType = setBit(faceType, 6, hasFaceColor);\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\n        faces.push(faceType);\n        faces.push(face.a, face.b, face.c);\n        faces.push(face.materialIndex);\n        if (hasFaceVertexUv) {\n          var faceVertexUvs = this.faceVertexUvs[0][_i12];\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n        }\n        if (hasFaceNormal) {\n          faces.push(getNormalIndex(face.normal));\n        }\n        if (hasFaceVertexNormal) {\n          var vertexNormals = face.vertexNormals;\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n        }\n        if (hasFaceColor) {\n          faces.push(getColorIndex(face.color));\n        }\n        if (hasFaceVertexColor) {\n          var vertexColors = face.vertexColors;\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n        }\n      }\n      function setBit(value, position, enabled) {\n        return enabled ? value | 1 << position : value & ~(1 << position);\n      }\n      function getNormalIndex(normal) {\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        if (normalsHash[hash] !== undefined) {\n          return normalsHash[hash];\n        }\n        normalsHash[hash] = normals.length / 3;\n        normals.push(normal.x, normal.y, normal.z);\n        return normalsHash[hash];\n      }\n      function getColorIndex(color) {\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\n        if (colorsHash[hash] !== undefined) {\n          return colorsHash[hash];\n        }\n        colorsHash[hash] = colors.length;\n        colors.push(color.getHex());\n        return colorsHash[hash];\n      }\n      function getUvIndex(uv) {\n        var hash = uv.x.toString() + uv.y.toString();\n        if (uvsHash[hash] !== undefined) {\n          return uvsHash[hash];\n        }\n        uvsHash[hash] = uvs.length / 2;\n        uvs.push(uv.x, uv.y);\n        return uvsHash[hash];\n      }\n      data.data = {};\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if (colors.length > 0) data.data.colors = colors;\n      if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n      data.data.faces = faces;\n      return data;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      /*\n      // Handle primitives\n      const parameters = this.parameters;\n      if ( parameters !== undefined ) {\n      const values = [];\n      for ( const key in parameters ) {\n      values.push( parameters[ key ] );\n      }\n      const geometry = Object.create( this.constructor.prototype );\n      this.constructor.apply( geometry, values );\n      return geometry;\n      }\n      return new this.constructor().copy( this );\n      */\n      return new Geometry().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      // reset\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null; // name\n\n      this.name = source.name; // vertices\n\n      var vertices = source.vertices;\n      for (var i = 0, il = vertices.length; i < il; i++) {\n        this.vertices.push(vertices[i].clone());\n      } // colors\n\n      var colors = source.colors;\n      for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\n        this.colors.push(colors[_i13].clone());\n      } // faces\n\n      var faces = source.faces;\n      for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\n        this.faces.push(faces[_i14].clone());\n      } // face vertex uvs\n\n      for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\n        var faceVertexUvs = source.faceVertexUvs[_i15];\n        if (this.faceVertexUvs[_i15] === undefined) {\n          this.faceVertexUvs[_i15] = [];\n        }\n        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n          var uvs = faceVertexUvs[j],\n            uvsCopy = [];\n          for (var k = 0, kl = uvs.length; k < kl; k++) {\n            var uv = uvs[k];\n            uvsCopy.push(uv.clone());\n          }\n          this.faceVertexUvs[_i15].push(uvsCopy);\n        }\n      } // morph targets\n\n      var morphTargets = source.morphTargets;\n      for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\n        var morphTarget = {};\n        morphTarget.name = morphTargets[_i16].name; // vertices\n\n        if (morphTargets[_i16].vertices !== undefined) {\n          morphTarget.vertices = [];\n          for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\n            morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\n          }\n        } // normals\n\n        if (morphTargets[_i16].normals !== undefined) {\n          morphTarget.normals = [];\n          for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\n            morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\n          }\n        }\n        this.morphTargets.push(morphTarget);\n      } // morph normals\n\n      var morphNormals = source.morphNormals;\n      for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\n        var morphNormal = {}; // vertex normals\n\n        if (morphNormals[_i17].vertexNormals !== undefined) {\n          morphNormal.vertexNormals = [];\n          for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\n            var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\n            var destVertexNormal = {};\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n            morphNormal.vertexNormals.push(destVertexNormal);\n          }\n        } // face normals\n\n        if (morphNormals[_i17].faceNormals !== undefined) {\n          morphNormal.faceNormals = [];\n          for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\n            morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\n          }\n        }\n        this.morphNormals.push(morphNormal);\n      } // skin weights\n\n      var skinWeights = source.skinWeights;\n      for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\n        this.skinWeights.push(skinWeights[_i18].clone());\n      } // skin indices\n\n      var skinIndices = source.skinIndices;\n      for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\n        this.skinIndices.push(skinIndices[_i19].clone());\n      } // line distances\n\n      var lineDistances = source.lineDistances;\n      for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\n        this.lineDistances.push(lineDistances[_i20]);\n      } // bounding box\n\n      var boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      } // bounding sphere\n\n      var boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      } // update flags\n\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n      return this;\n    }\n  }, {\n    key: \"toBufferGeometry\",\n    value: function toBufferGeometry() {\n      var geometry = new DirectGeometry().fromGeometry(this);\n      var buffergeometry = new BufferGeometry();\n      var positions = new Float32Array(geometry.vertices.length * 3);\n      buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n      if (geometry.normals.length > 0) {\n        var normals = new Float32Array(geometry.normals.length * 3);\n        buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n      }\n      if (geometry.colors.length > 0) {\n        var colors = new Float32Array(geometry.colors.length * 3);\n        buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n      }\n      if (geometry.uvs.length > 0) {\n        var uvs = new Float32Array(geometry.uvs.length * 2);\n        buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n      }\n      if (geometry.uvs2.length > 0) {\n        var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n        buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n      } // groups\n\n      buffergeometry.groups = geometry.groups; // morphs\n\n      for (var name in geometry.morphTargets) {\n        var array = [];\n        var morphTargets = geometry.morphTargets[name];\n        for (var i = 0, l = morphTargets.length; i < l; i++) {\n          var morphTarget = morphTargets[i];\n          var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n          attribute.name = morphTarget.name;\n          array.push(attribute.copyVector3sArray(morphTarget.data));\n        }\n        buffergeometry.morphAttributes[name] = array;\n      } // skinning\n\n      if (geometry.skinIndices.length > 0) {\n        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n        buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n      }\n      if (geometry.skinWeights.length > 0) {\n        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n        buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n      } //\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n      return buffergeometry;\n    }\n  }, {\n    key: \"computeTangents\",\n    value: function computeTangents() {\n      console.error('THREE.Geometry: .computeTangents() has been removed.');\n    }\n  }, {\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n    }\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n      return this.applyMatrix4(matrix);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n    }\n  }]);\n  return Geometry;\n}(EventDispatcher);\nGeometry.createBufferGeometryFromObject = function (object) {\n  var buffergeometry = new BufferGeometry();\n  var geometry = object.geometry;\n  if (object.isPoints || object.isLine) {\n    var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n  return buffergeometry;\n};\nvar DirectGeometry = /*#__PURE__*/function () {\n  function DirectGeometry() {\n    _classCallCheck(this, DirectGeometry);\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  _createClass(DirectGeometry, [{\n    key: \"computeGroups\",\n    value: function computeGroups(geometry) {\n      var groups = [];\n      var group, i;\n      var materialIndex = undefined;\n      var faces = geometry.faces;\n      for (i = 0; i < faces.length; i++) {\n        var face = faces[i]; // materials\n\n        if (face.materialIndex !== materialIndex) {\n          materialIndex = face.materialIndex;\n          if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n          }\n          group = {\n            start: i * 3,\n            materialIndex: materialIndex\n          };\n        }\n      }\n      if (group !== undefined) {\n        group.count = i * 3 - group.start;\n        groups.push(group);\n      }\n      this.groups = groups;\n    }\n  }, {\n    key: \"fromGeometry\",\n    value: function fromGeometry(geometry) {\n      var faces = geometry.faces;\n      var vertices = geometry.vertices;\n      var faceVertexUvs = geometry.faceVertexUvs;\n      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n      var morphTargets = geometry.morphTargets;\n      var morphTargetsLength = morphTargets.length;\n      var morphTargetsPosition;\n      if (morphTargetsLength > 0) {\n        morphTargetsPosition = [];\n        for (var i = 0; i < morphTargetsLength; i++) {\n          morphTargetsPosition[i] = {\n            name: morphTargets[i].name,\n            data: []\n          };\n        }\n        this.morphTargets.position = morphTargetsPosition;\n      }\n      var morphNormals = geometry.morphNormals;\n      var morphNormalsLength = morphNormals.length;\n      var morphTargetsNormal;\n      if (morphNormalsLength > 0) {\n        morphTargetsNormal = [];\n        for (var _i21 = 0; _i21 < morphNormalsLength; _i21++) {\n          morphTargetsNormal[_i21] = {\n            name: morphNormals[_i21].name,\n            data: []\n          };\n        }\n        this.morphTargets.normal = morphTargetsNormal;\n      } // skins\n\n      var skinIndices = geometry.skinIndices;\n      var skinWeights = geometry.skinWeights;\n      var hasSkinIndices = skinIndices.length === vertices.length;\n      var hasSkinWeights = skinWeights.length === vertices.length; //\n\n      if (vertices.length > 0 && faces.length === 0) {\n        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n      }\n      for (var _i22 = 0; _i22 < faces.length; _i22++) {\n        var face = faces[_i22];\n        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n        var vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n        } else {\n          var normal = face.normal;\n          this.normals.push(normal, normal, normal);\n        }\n        var vertexColors = face.vertexColors;\n        if (vertexColors.length === 3) {\n          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n        } else {\n          var color = face.color;\n          this.colors.push(color, color, color);\n        }\n        if (hasFaceVertexUv === true) {\n          var vertexUvs = faceVertexUvs[0][_i22];\n          if (vertexUvs !== undefined) {\n            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', _i22);\n            this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        }\n        if (hasFaceVertexUv2 === true) {\n          var _vertexUvs = faceVertexUvs[1][_i22];\n          if (_vertexUvs !== undefined) {\n            this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', _i22);\n            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        } // morphs\n\n        for (var j = 0; j < morphTargetsLength; j++) {\n          var morphTarget = morphTargets[j].vertices;\n          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n        }\n        for (var _j7 = 0; _j7 < morphNormalsLength; _j7++) {\n          var morphNormal = morphNormals[_j7].vertexNormals[_i22];\n          morphTargetsNormal[_j7].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n        } // skins\n\n        if (hasSkinIndices) {\n          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n        }\n        if (hasSkinWeights) {\n          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n        }\n      }\n      this.computeGroups(geometry);\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n      return this;\n    }\n  }]);\n  return DirectGeometry;\n}();\nvar Face3 = /*#__PURE__*/function () {\n  function Face3(a, b, c, normal, color) {\n    var materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    _classCallCheck(this, Face3);\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  _createClass(Face3, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.a = source.a;\n      this.b = source.b;\n      this.c = source.c;\n      this.normal.copy(source.normal);\n      this.color.copy(source.color);\n      this.materialIndex = source.materialIndex;\n      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n        this.vertexNormals[i] = source.vertexNormals[i].clone();\n      }\n      for (var _i23 = 0, _il15 = source.vertexColors.length; _i23 < _il15; _i23++) {\n        this.vertexColors[_i23] = source.vertexColors[_i23].clone();\n      }\n      return this;\n    }\n  }]);\n  return Face3;\n}();\nexport { Face3, Geometry };","map":{"version":3,"names":["Matrix4","Object3D","Vector3","EventDispatcher","MathUtils","Matrix3","Color","Box3","Sphere","BufferGeometry","BufferAttribute","Float32BufferAttribute","Vector2","_m1","_obj","_offset","Geometry","isGeometry","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","applyMatrix4","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","angle","makeRotationX","makeRotationY","makeRotationZ","x","y","z","makeTranslation","makeScale","vector","lookAt","updateMatrix","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","groups","group","start","getX","computeFaceNormals","getCenter","negate","translate","center","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","areaWeighted","Array","v","vl","add","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","computeVertexNormals","setFromPoints","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mesh","isMesh","matrixAutoUpdate","merge","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","warn","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","toBufferGeometry","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","computeGroups","isVector3","isArray","isColor","constructor"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/deprecated/Geometry.js"],"sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}