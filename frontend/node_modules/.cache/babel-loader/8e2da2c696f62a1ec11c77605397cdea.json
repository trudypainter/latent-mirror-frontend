{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar Visible = 0;\nvar Deleted = 1;\nvar _v1 = new Vector3();\nvar _line3 = new Line3();\nvar _plane = new Plane();\nvar _closestPoint = new Vector3();\nvar _triangle = new Triangle();\nvar ConvexHull = /*#__PURE__*/function () {\n  function ConvexHull() {\n    _classCallCheck(this, ConvexHull);\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n  _createClass(ConvexHull, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      // The algorithm needs at least four points.\n      if (points.length >= 4) {\n        this.makeEmpty();\n        for (var i = 0, l = points.length; i < l; i++) {\n          this.vertices.push(new VertexNode(points[i]));\n        }\n        this.compute();\n      }\n      return this;\n    }\n  }, {\n    key: \"setFromObject\",\n    value: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var geometry = node.geometry;\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n            if (attribute !== undefined) {\n              for (var i = 0, l = attribute.count; i < l; i++) {\n                var point = new Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var faces = this.faces;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n      return target;\n    }\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      return this.intersectRay(ray, _v1) !== null;\n    }\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  }, {\n    key: \"addVertexToFace\",\n    value: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n      face.outside = vertex;\n      return this;\n    } // Removes a vertex from the 'assigned' list of vertices and from the given face\n  }, {\n    key: \"removeVertexFromFace\",\n    value: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n      this.assigned.remove(vertex);\n      return this;\n    } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n  }, {\n    key: \"removeAllVerticesFromFace\",\n    value: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    } // Removes all the visible vertices that 'face' is able to see\n  }, {\n    key: \"deleteFaceVertices\",\n    value: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n      return this;\n    } // Reassigns as many vertices as possible from the unassigned list to the new faces\n  }, {\n    key: \"resolveUnassignedPoints\",\n    value: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n      return this;\n    } // Computes the extremes of a simplex which will be the initial hull\n  }, {\n    key: \"computeExtremes\",\n    value: function computeExtremes() {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = []; // initially assume that the first vertex is the min/max\n\n      for (var i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (var _i = 0, l = this.vertices.length; _i < l; _i++) {\n        var vertex = this.vertices[_i];\n        var point = vertex.point; // update the min coordinates\n\n        for (var j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n        for (var _j = 0; _j < 3; _j++) {\n          if (point.getComponent(_j) > max.getComponent(_j)) {\n            max.setComponent(_j, point.getComponent(_j));\n            maxVertices[_j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    } // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n  }, {\n    key: \"computeInitialHull\",\n    value: function computeInitialHull() {\n      var vertices = this.vertices;\n      var extremes = this.computeExtremes();\n      var min = extremes.min;\n      var max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n      // (max.x - min.x)\n      // (max.y - min.y)\n      // (max.z - min.z)\n\n      var maxDistance = 0;\n      var index = 0;\n      for (var i = 0; i < 3; i++) {\n        var distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          index = i;\n        }\n      }\n      var v0 = min[index];\n      var v1 = max[index];\n      var v2;\n      var v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n      maxDistance = 0;\n      _line3.set(v0.point, v1.point);\n      for (var _i2 = 0, l = this.vertices.length; _i2 < l; _i2++) {\n        var vertex = vertices[_i2];\n        if (vertex !== v0 && vertex !== v1) {\n          _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n          var _distance = _closestPoint.distanceToSquared(vertex.point);\n          if (_distance > maxDistance) {\n            maxDistance = _distance;\n            v2 = vertex;\n          }\n        }\n      } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n      maxDistance = -1;\n      _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n      for (var _i3 = 0, _l = this.vertices.length; _i3 < _l; _i3++) {\n        var _vertex = vertices[_i3];\n        if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {\n          var _distance2 = Math.abs(_plane.distanceToPoint(_vertex.point));\n          if (_distance2 > maxDistance) {\n            maxDistance = _distance2;\n            v3 = _vertex;\n          }\n        }\n      }\n      var faces = [];\n      if (_plane.distanceToPoint(v3.point) < 0) {\n        // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n        faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          var j = (_i4 + 1) % 3; // join face[ i ] i > 0, with the first face\n\n          faces[_i4 + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n          faces[_i4 + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n        }\n      } else {\n        // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n        faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n        for (var _i5 = 0; _i5 < 3; _i5++) {\n          var _j2 = (_i5 + 1) % 3; // join face[ i ] i > 0, with the first face\n\n          faces[_i5 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - _i5) % 3)); // join face[ i ] with face[ i + 1 ]\n\n          faces[_i5 + 1].getEdge(0).setTwin(faces[_j2 + 1].getEdge(1));\n        }\n      } // the initial hull is the tetrahedron\n\n      for (var _i6 = 0; _i6 < 4; _i6++) {\n        this.faces.push(faces[_i6]);\n      } // initial assignment of vertices to the faces of the tetrahedron\n\n      for (var _i7 = 0, _l2 = vertices.length; _i7 < _l2; _i7++) {\n        var _vertex2 = vertices[_i7];\n        if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {\n          maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            var _distance3 = this.faces[_j3].distanceToPoint(_vertex2.point);\n            if (_distance3 > maxDistance) {\n              maxDistance = _distance3;\n              maxFace = this.faces[_j3];\n            }\n          }\n          if (maxFace !== null) {\n            this.addVertexToFace(_vertex2, maxFace);\n          }\n        }\n      }\n      return this;\n    } // Removes inactive faces\n  }, {\n    key: \"reindexFaces\",\n    value: function reindexFaces() {\n      var activeFaces = [];\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n      this.faces = activeFaces;\n      return this;\n    } // Finds the next vertex to create faces with the current hull\n  }, {\n    key: \"nextVertexToAdd\",\n    value: function nextVertexToAdd() {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n        return eyeVertex;\n      }\n    } // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n  }, {\n    key: \"computeHorizon\",\n    value: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n        edge = edge.next;\n      } while (edge !== crossEdge);\n      return this;\n    } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  }, {\n    key: \"addAdjoiningFace\",\n    value: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n  }, {\n    key: \"addNewFaces\",\n    value: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    } // Adds a vertex to the hull\n  }, {\n    key: \"addVertexToHull\",\n    value: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }]);\n  return ConvexHull;\n}(); //\nvar Face = /*#__PURE__*/function () {\n  function Face() {\n    _classCallCheck(this, Face);\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n  _createClass(Face, [{\n    key: \"getEdge\",\n    value: function getEdge(i) {\n      var edge = this.edge;\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n      return edge;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var a = this.edge.tail();\n      var b = this.edge.head();\n      var c = this.edge.next.head();\n      _triangle.set(a.point, b.point, c.point);\n      _triangle.getNormal(this.normal);\n      _triangle.getMidpoint(this.midpoint);\n      this.area = _triangle.getArea();\n      this.constant = this.normal.dot(this.midpoint);\n      return this;\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  }]);\n  return Face;\n}(); // Entity for a Doubly-Connected Edge List (DCEL).\nvar HalfEdge = /*#__PURE__*/function () {\n  function HalfEdge(vertex, face) {\n    _classCallCheck(this, HalfEdge);\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  _createClass(HalfEdge, [{\n    key: \"head\",\n    value: function head() {\n      return this.vertex;\n    }\n  }, {\n    key: \"tail\",\n    value: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"setTwin\",\n    value: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }]);\n  return HalfEdge;\n}(); // A vertex as a double linked list node.\nvar VertexNode = /*#__PURE__*/_createClass(function VertexNode(point) {\n  _classCallCheck(this, VertexNode);\n  this.point = point;\n  this.prev = null;\n  this.next = null;\n  this.face = null; // the face that is able to see this vertex\n}); // A double linked list that contains vertex nodes.\nvar VertexList = /*#__PURE__*/function () {\n  function VertexList() {\n    _classCallCheck(this, VertexList);\n    this.head = null;\n    this.tail = null;\n  }\n  _createClass(VertexList, [{\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.tail;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      return this;\n    } // Inserts a vertex before the target vertex\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n      target.prev = vertex;\n      return this;\n    } // Inserts a vertex after the target vertex\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n      target.next = vertex;\n      return this;\n    } // Appends a vertex to the end of the linked list\n  }, {\n    key: \"append\",\n    value: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    } // Appends a chain of vertices where 'vertex' is the head.\n  }, {\n    key: \"appendChain\",\n    value: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n      this.tail = vertex;\n      return this;\n    } // Removes a vertex from the linked list\n  }, {\n    key: \"remove\",\n    value: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n      return this;\n    } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  }, {\n    key: \"removeSubList\",\n    value: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n      return this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.head === null;\n    }\n  }]);\n  return VertexList;\n}();\nexport { ConvexHull };","map":{"version":3,"names":["Vector3","Line3","Plane","Triangle","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","points","length","makeEmpty","i","l","push","VertexNode","compute","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","console","error","isBufferGeometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","setFromPoints","face","distanceToPoint","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectRay","vertex","outside","append","insertBefore","next","remove","start","end","removeSubList","prev","absorbingFace","faceVertices","removeAllVerticesFromFace","appendChain","nextVertex","distance","addVertexToFace","isEmpty","first","maxDistance","maxFace","mark","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","extremes","computeExtremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","activeFaces","eyeVertex","eyeFace","eyePoint","crossEdge","horizon","deleteFaceVertices","edge","twinEdge","twin","oppositeFace","computeHorizon","horizonEdge","tail","head","firstSideEdge","previousSideEdge","sideEdge","addAdjoiningFace","clear","removeVertexFromFace","addNewFaces","resolveUnassignedPoints","computeInitialHull","nextVertexToAdd","addVertexToHull","reindexFaces","cleanup","midpoint","area","constant","a","b","c","getNormal","getMidpoint","getArea","e0","HalfEdge","e1","e2","distanceTo"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/math/ConvexHull.js"],"sourcesContent":["import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\n\nconst _line3 = new Line3();\n\nconst _plane = new Plane();\n\nconst _closestPoint = new Vector3();\n\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n    if (points.length >= 4) {\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n    }\n\n    return this;\n  }\n\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position;\n\n          if (attribute !== undefined) {\n            for (let i = 0, l = attribute.count; i < l; i++) {\n              const point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  containsPoint(point) {\n    const faces = this.faces;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n\n    return true;\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        //  plane faces away from the ray, so this plane is a back-face\n        tFar = Math.min(t, tFar);\n      } else {\n        // front-face\n        tNear = Math.max(t, tNear);\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n        return null;\n      }\n    } // evaluate intersection point\n    // always try tNear first since its the closer intersection point\n\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n\n    return target;\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n\n    face.outside = vertex;\n    return this;\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n        face.outside = vertex.next;\n      } else {\n        // vertex was the only outside vertex that face had\n        face.outside = null;\n      }\n    }\n\n    this.assigned.remove(vertex);\n    return this;\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n      const start = face.outside;\n      let end = face.outside;\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n\n      this.assigned.removeSubList(start, end); // fix references\n\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  } // Removes all the visible vertices that 'face' is able to see\n\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n        let vertex = faceVertices;\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          } // now assign next vertex\n\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n\n    return this;\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break;\n          }\n        } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n\n    return this;\n  } // Computes the extremes of a simplex which will be the initial hull\n\n\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = []; // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point; // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      } // update the max coordinates\n\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    } // use min/max vectors to compute an optimal epsilon\n\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  } // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0;\n    let index = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0;\n\n    _line3.set(v0.point, v1.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n    maxDistance = -1;\n\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n\n    const faces = [];\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    } // the initial hull is the tetrahedron\n\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    } // initial assignment of vertices to the faces of the tetrahedron\n\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n\n    return this;\n  } // Removes inactive faces\n\n\n  reindexFaces() {\n    const activeFaces = [];\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n\n    this.faces = activeFaces;\n    return this;\n  } // Finds the next vertex to create faces with the current hull\n\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n\n      return eyeVertex;\n    }\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n      edge = crossEdge.next;\n    }\n\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n          horizon.push(edge);\n        }\n      }\n\n      edge = edge.next;\n    } while (edge !== crossEdge);\n\n    return this;\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]; // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    } // perform final join of new faces\n\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  } // Adds a vertex to the hull\n\n\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  compute() {\n    let vertex;\n    this.computeInitialHull(); // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex);\n    }\n\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n\n} //\n\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face); // join edges\n\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0; // main half edge reference\n\n    face.edge = e0;\n    return face.compute();\n  }\n\n  getEdge(i) {\n    let edge = this.edge;\n\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n\n    return edge;\n  }\n\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n\n    _triangle.set(a.point, b.point, c.point);\n\n    _triangle.getNormal(this.normal);\n\n    _triangle.getMidpoint(this.midpoint);\n\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n\n} // Entity for a Doubly-Connected Edge List (DCEL).\n\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  head() {\n    return this.vertex;\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n\n    return -1;\n  }\n\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n\n    return -1;\n  }\n\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n\n} // A vertex as a double linked list node.\n\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  }\n\n} // A double linked list that contains vertex nodes.\n\n\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.tail;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  } // Inserts a vertex before the target vertex\n\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n\n    target.prev = vertex;\n    return this;\n  } // Inserts a vertex after the target vertex\n\n\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n\n    target.next = vertex;\n    return this;\n  } // Appends a vertex to the end of the linked list\n\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n    vertex.next = null; // the tail has no subsequent vertex\n\n    this.tail = vertex;\n    return this;\n  } // Appends a chain of vertices where 'vertex' is the head.\n\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n\n    this.tail = vertex;\n    return this;\n  } // Removes a vertex from the linked list\n\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n\n    return this;\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n}\n\nexport { ConvexHull };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}