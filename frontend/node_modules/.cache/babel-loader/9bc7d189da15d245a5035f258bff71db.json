{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar parser_1 = require(\"../parser/parser\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar lookahead_1 = require(\"./lookahead\");\nvar interpreter_1 = require(\"./interpreter\");\nvar gast_2 = require(\"@chevrotain/gast\");\nvar gast_3 = require(\"@chevrotain/gast\");\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar tokens_1 = require(\"../../scan/tokens\");\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = [];\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n    emptyAltErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(gast_3.GAstVisitor);\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetitionCollector = /** @class */function (_super) {\n  __extends(RepetitionCollector, _super);\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\nexports.RepetitionCollector = RepetitionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","exports","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","type","parser_1","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_2","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_3","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","tokens_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  globalMaxLookahead: number,\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors = flatMap(topLevels, (currTopLevel) =>\n    validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n  const leftRecursionErrors = flatMap(topLevels, (currTopRule) =>\n    validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider)\n  )\n\n  let emptyAltErrors: IParserEmptyAlternativeDefinitionError[] = []\n  let ambiguousAltsErrors: IParserAmbiguousAlternativesDefinitionError[] = []\n  let emptyRepetitionErrors: IParserDefinitionError[] = []\n\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (isEmpty(leftRecursionErrors)) {\n    emptyAltErrors = flatMap(topLevels, (currTopRule) =>\n      validateEmptyOrAlternative(currTopRule, errMsgProvider)\n    )\n    ambiguousAltsErrors = flatMap(topLevels, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        globalMaxLookahead,\n        errMsgProvider\n      )\n    )\n\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(\n      topLevels,\n      globalMaxLookahead,\n      errMsgProvider\n    )\n  }\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return (duplicateErrors as IParserDefinitionError[]).concat(\n    emptyRepetitionErrors,\n    leftRecursionErrors,\n    emptyAltErrors,\n    ambiguousAltsErrors,\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(<any>nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"]},"metadata":{},"sourceType":"script"}