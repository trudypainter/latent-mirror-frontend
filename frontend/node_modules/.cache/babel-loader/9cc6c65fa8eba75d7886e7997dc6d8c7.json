{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar NodeKeywords = /*#__PURE__*/function () {\n  function NodeKeywords() {\n    _classCallCheck(this, NodeKeywords);\n    this.keywords = [];\n    this.nodes = [];\n    this.keywordsCallback = {};\n  }\n  _createClass(NodeKeywords, [{\n    key: \"getNode\",\n    value: function getNode(name) {\n      var node = this.nodes[name];\n      if (node === undefined && this.keywordsCallback[name] !== undefined) {\n        node = this.keywordsCallback[name](name);\n        this.nodes[name] = node;\n      }\n      return node;\n    }\n  }, {\n    key: \"addKeyword\",\n    value: function addKeyword(name, callback) {\n      this.keywords.push(name);\n      this.keywordsCallback[name] = callback;\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(code) {\n      var keywordNames = this.keywords;\n      var regExp = new RegExp(\"\\\\b\".concat(keywordNames.join('\\\\b|\\\\b'), \"\\\\b\"), 'g');\n      var codeKeywords = code.match(regExp);\n      var keywordNodes = [];\n      if (codeKeywords !== null) {\n        var _iterator = _createForOfIteratorHelper(codeKeywords),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var keyword = _step.value;\n            var node = this.getNode(keyword);\n            if (node !== undefined && keywordNodes.indexOf(node) === -1) {\n              keywordNodes.push(node);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return keywordNodes;\n    }\n  }, {\n    key: \"include\",\n    value: function include(builder, code) {\n      var keywordNodes = this.parse(code);\n      var _iterator2 = _createForOfIteratorHelper(keywordNodes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var keywordNode = _step2.value;\n          keywordNode.build(builder);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n  return NodeKeywords;\n}();\nexport default NodeKeywords;","map":{"version":3,"names":["NodeKeywords","keywords","nodes","keywordsCallback","name","node","undefined","callback","push","code","keywordNames","regExp","RegExp","join","codeKeywords","match","keywordNodes","keyword","getNode","indexOf","builder","parse","keywordNode","build"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/nodes/core/NodeKeywords.js"],"sourcesContent":["class NodeKeywords {\n  constructor() {\n    this.keywords = [];\n    this.nodes = [];\n    this.keywordsCallback = {};\n  }\n\n  getNode(name) {\n    let node = this.nodes[name];\n\n    if (node === undefined && this.keywordsCallback[name] !== undefined) {\n      node = this.keywordsCallback[name](name);\n      this.nodes[name] = node;\n    }\n\n    return node;\n  }\n\n  addKeyword(name, callback) {\n    this.keywords.push(name);\n    this.keywordsCallback[name] = callback;\n    return this;\n  }\n\n  parse(code) {\n    const keywordNames = this.keywords;\n    const regExp = new RegExp(`\\\\b${keywordNames.join('\\\\b|\\\\b')}\\\\b`, 'g');\n    const codeKeywords = code.match(regExp);\n    const keywordNodes = [];\n\n    if (codeKeywords !== null) {\n      for (const keyword of codeKeywords) {\n        const node = this.getNode(keyword);\n\n        if (node !== undefined && keywordNodes.indexOf(node) === -1) {\n          keywordNodes.push(node);\n        }\n      }\n    }\n\n    return keywordNodes;\n  }\n\n  include(builder, code) {\n    const keywordNodes = this.parse(code);\n\n    for (const keywordNode of keywordNodes) {\n      keywordNode.build(builder);\n    }\n  }\n\n}\n\nexport default NodeKeywords;\n"],"mappings":";;;IAAMA,YAAY;EAChB,wBAAc;IAAA;IACZ,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC;EAC5B;EAAC;IAAA;IAAA,OAED,iBAAQC,IAAI,EAAE;MACZ,IAAIC,IAAI,GAAG,IAAI,CAACH,KAAK,CAACE,IAAI,CAAC;MAE3B,IAAIC,IAAI,KAAKC,SAAS,IAAI,IAAI,CAACH,gBAAgB,CAACC,IAAI,CAAC,KAAKE,SAAS,EAAE;QACnED,IAAI,GAAG,IAAI,CAACF,gBAAgB,CAACC,IAAI,CAAC,CAACA,IAAI,CAAC;QACxC,IAAI,CAACF,KAAK,CAACE,IAAI,CAAC,GAAGC,IAAI;MACzB;MAEA,OAAOA,IAAI;IACb;EAAC;IAAA;IAAA,OAED,oBAAWD,IAAI,EAAEG,QAAQ,EAAE;MACzB,IAAI,CAACN,QAAQ,CAACO,IAAI,CAACJ,IAAI,CAAC;MACxB,IAAI,CAACD,gBAAgB,CAACC,IAAI,CAAC,GAAGG,QAAQ;MACtC,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAED,eAAME,IAAI,EAAE;MACV,IAAMC,YAAY,GAAG,IAAI,CAACT,QAAQ;MAClC,IAAMU,MAAM,GAAG,IAAIC,MAAM,cAAOF,YAAY,CAACG,IAAI,CAAC,SAAS,CAAC,UAAO,GAAG,CAAC;MACvE,IAAMC,YAAY,GAAGL,IAAI,CAACM,KAAK,CAACJ,MAAM,CAAC;MACvC,IAAMK,YAAY,GAAG,EAAE;MAEvB,IAAIF,YAAY,KAAK,IAAI,EAAE;QAAA,2CACHA,YAAY;UAAA;QAAA;UAAlC,oDAAoC;YAAA,IAAzBG,OAAO;YAChB,IAAMZ,IAAI,GAAG,IAAI,CAACa,OAAO,CAACD,OAAO,CAAC;YAElC,IAAIZ,IAAI,KAAKC,SAAS,IAAIU,YAAY,CAACG,OAAO,CAACd,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;cAC3DW,YAAY,CAACR,IAAI,CAACH,IAAI,CAAC;YACzB;UACF;QAAC;UAAA;QAAA;UAAA;QAAA;MACH;MAEA,OAAOW,YAAY;IACrB;EAAC;IAAA;IAAA,OAED,iBAAQI,OAAO,EAAEX,IAAI,EAAE;MACrB,IAAMO,YAAY,GAAG,IAAI,CAACK,KAAK,CAACZ,IAAI,CAAC;MAAC,4CAEZO,YAAY;QAAA;MAAA;QAAtC,uDAAwC;UAAA,IAA7BM,WAAW;UACpBA,WAAW,CAACC,KAAK,CAACH,OAAO,CAAC;QAC5B;MAAC;QAAA;MAAA;QAAA;MAAA;IACH;EAAC;EAAA;AAAA;AAIH,eAAepB,YAAY"},"metadata":{},"sourceType":"module"}