{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, Plane, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget, HalfFloatType, NoToneMapping, LinearEncoding } from 'three';\nclass Reflector extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.isReflector = true;\n    this.type = 'Reflector';\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader;\n    const multisample = options.multisample !== undefined ? options.multisample : 4;\n\n    //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n\n      // Render\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputEncoding = renderer.outputEncoding;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false; // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n      renderer.outputEncoding = LinearEncoding;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputEncoding = currentOutputEncoding;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nReflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n};\nexport { Reflector };","map":{"version":3,"names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","NoToneMapping","LinearEncoding","Reflector","constructor","geometry","options","isReflector","type","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputEncoding","outputEncoding","currentToneMapping","toneMapping","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType,\n\tNoToneMapping,\n\tLinearEncoding\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentOutputEncoding = renderer.outputEncoding;\n\t\t\tconst currentToneMapping = renderer.toneMapping;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.outputEncoding = LinearEncoding;\n\t\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.outputEncoding = currentOutputEncoding;\n\t\t\trenderer.toneMapping = currentToneMapping;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}