{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\nvar _start = new Vector3();\nvar _end = new Vector3();\nvar _start4 = new Vector4();\nvar _end4 = new Vector4();\nvar _ssOrigin = new Vector4();\nvar _ssOrigin3 = new Vector3();\nvar _mvMatrix = new Matrix4();\nvar _line = new Line3();\nvar _closestPoint = new Vector3();\nvar _box = new Box3();\nvar _sphere = new Sphere();\nvar _clipToWorldVector = new Vector4();\nvar _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (var i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n    var pointOnLine = new Vector3();\n    var point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    var isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  var projectionMatrix = camera.projectionMatrix;\n  var material = lineSegments.material;\n  var resolution = material.resolution;\n  var matrixWorld = lineSegments.matrixWorld;\n  var geometry = lineSegments.geometry;\n  var instanceStart = geometry.attributes.instanceStart;\n  var instanceEnd = geometry.attributes.instanceEnd;\n  var near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (var i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n    var isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n    if (_start4.z > near) {\n      var deltaDist = _start4.z - _end4.z;\n      var t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      var _deltaDist = _end4.z - _start4.z;\n      var _t = (_end4.z - near) / _deltaDist;\n      _end4.lerp(_start4, _t);\n    } // clip space\n\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0; // get closest point on ray to segment\n\n    var param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n    var zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    var isInClipSpace = zPos >= -1 && zPos <= 1;\n    var isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      var pointOnLine = new Vector3();\n      var point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nvar LineSegments2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(LineSegments2, _Mesh);\n  var _super = _createSuper(LineSegments2);\n  function LineSegments2() {\n    var _this;\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    _classCallCheck(this, LineSegments2);\n    _this = _super.call(this, geometry, material);\n    _this.isLineSegments2 = true;\n    _this.type = 'LineSegments2';\n    return _this;\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  _createClass(LineSegments2, [{\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.count);\n      for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var worldUnits = this.material.worldUnits;\n      var camera = raycaster.camera;\n      if (camera === null && !worldUnits) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n      }\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      _ray = raycaster.ray;\n      var matrixWorld = this.matrixWorld;\n      var geometry = this.geometry;\n      var material = this.material;\n      _lineWidth = material.linewidth + threshold;\n      _instanceStart = geometry.attributes.instanceStart;\n      _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n      _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n      var sphereMargin;\n      if (worldUnits) {\n        sphereMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n        sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n      }\n      _sphere.radius += sphereMargin;\n      if (_ray.intersectsSphere(_sphere) === false) {\n        return;\n      } // check if we intersect the box bounds\n\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n      var boxMargin;\n      if (worldUnits) {\n        boxMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n        boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n      }\n      _box.expandByScalar(boxMargin);\n      if (_ray.intersectsBox(_box) === false) {\n        return;\n      }\n      if (worldUnits) {\n        raycastWorldUnits(this, intersects);\n      } else {\n        raycastScreenSpace(this, camera, intersects);\n      }\n    }\n  }]);\n  return LineSegments2;\n}(Mesh);\nexport { LineSegments2 };","map":{"version":3,"names":["Vector3","Vector4","Matrix4","Line3","Box3","Sphere","Mesh","InstancedInterleavedBuffer","InterleavedBufferAttribute","MathUtils","LineSegmentsGeometry","LineMaterial","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_instanceStart","_instanceEnd","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","i","l","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","uv2","raycastScreenSpace","material","matrixWorld","geometry","instanceStart","attributes","instanceEnd","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","LineSegments2","color","random","isLineSegments2","type","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycaster","worldUnits","console","error","threshold","params","Line2","undefined","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/three-stdlib/lines/LineSegments2.js"],"sourcesContent":["import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n\n  _ssOrigin.w = 1;\n\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n  _ssOrigin.applyMatrix4(projectionMatrix);\n\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n\n  _ssOrigin3.copy(_ssOrigin);\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n\n    _end4.fromBufferAttribute(instanceEnd, i);\n\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n\n      _end4.lerp(_start4, t);\n    } // clip space\n\n\n    _start4.applyMatrix4(projectionMatrix);\n\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n    _start4.multiplyScalar(1 / _start4.w);\n\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n\n    _line.start.z = 0;\n\n    _line.end.copy(_end4);\n\n    _line.end.z = 0; // get closest point on ray to segment\n\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n\n      _line.end.fromBufferAttribute(instanceEnd, i);\n\n      _line.start.applyMatrix4(matrixWorld);\n\n      _line.end.applyMatrix4(matrixWorld);\n\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n\n    let sphereMargin;\n\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n\n    _sphere.radius += sphereMargin;\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    } // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n\n    let boxMargin;\n\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n\n    _box.expandByScalar(boxMargin);\n\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n\n}\n\nexport { LineSegments2 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}