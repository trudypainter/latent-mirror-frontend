{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\nvar VTKLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VTKLoader, _Loader);\n  var _super = _createSuper(VTKLoader);\n  function VTKLoader(manager) {\n    _classCallCheck(this, VTKLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(VTKLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseASCII(data) {\n        // connectivity of the triangles\n        var indices = []; // triangles vertices\n\n        var positions = []; // red, green, blue colors in the range 0 to 1\n\n        var colors = []; // normal vector, one per vertex\n\n        var normals = [];\n        var result; // pattern for detecting the end of a number sequence\n\n        var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n        var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n        // the first integer is the number of polygon nodes\n\n        var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n        var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n        var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n        var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n        var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n        var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n        var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n        var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n        var inPointsSection = false;\n        var inPolygonsSection = false;\n        var inTriangleStripSection = false;\n        var inPointDataSection = false;\n        var inCellDataSection = false;\n        var inColorSection = false;\n        var inNormalsSection = false;\n        var lines = data.split('\\n');\n        for (var i in lines) {\n          var line = lines[i].trim();\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (inPointsSection) {\n            // get the vertices\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var x = parseFloat(result[1]);\n              var y = parseFloat(result[2]);\n              var z = parseFloat(result[3]);\n              positions.push(x, y, z);\n            }\n          } else if (inPolygonsSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n              if (numVertices >= 3) {\n                var i0 = parseInt(inds[0]);\n                var i1, i2;\n                var k = 1; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; ++j) {\n                  i1 = parseInt(inds[k]);\n                  i2 = parseInt(inds[k + 1]);\n                  indices.push(i0, i1, i2);\n                  k++;\n                }\n              }\n            }\n          } else if (inTriangleStripSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n              if (numVertices >= 3) {\n                var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; j++) {\n                  if (j % 2 === 1) {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 2]);\n                    i2 = parseInt(inds[j + 1]);\n                    indices.push(i0, i1, i2);\n                  } else {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 1]);\n                    i2 = parseInt(inds[j + 2]);\n                    indices.push(i0, i1, i2);\n                  }\n                }\n              }\n            }\n          } else if (inPointDataSection || inCellDataSection) {\n            if (inColorSection) {\n              // Get the colors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var r = parseFloat(result[1]);\n                var g = parseFloat(result[2]);\n                var b = parseFloat(result[3]);\n                colors.push(r, g, b);\n              }\n            } else if (inNormalsSection) {\n              // Get the normal vectors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var nx = parseFloat(result[1]);\n                var ny = parseFloat(result[2]);\n                var nz = parseFloat(result[3]);\n                normals.push(nx, ny, nz);\n              }\n            }\n          }\n          if (patPOLYGONS.exec(line) !== null) {\n            inPolygonsSection = true;\n            inPointsSection = false;\n            inTriangleStripSection = false;\n          } else if (patPOINTS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = true;\n            inTriangleStripSection = false;\n          } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = false;\n            inTriangleStripSection = true;\n          } else if (patPOINT_DATA.exec(line) !== null) {\n            inPointDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCELL_DATA.exec(line) !== null) {\n            inCellDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCOLOR_SCALARS.exec(line) !== null) {\n            inColorSection = true;\n            inNormalsSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patNORMALS.exec(line) !== null) {\n            inNormalsSection = true;\n            inColorSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(indices);\n        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n        if (normals.length === positions.length) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n        }\n        if (colors.length !== indices.length) {\n          // stagger\n          if (colors.length === positions.length) {\n            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n          }\n        } else {\n          // cell\n          geometry = geometry.toNonIndexed();\n          var numTriangles = geometry.attributes.position.count / 3;\n          if (colors.length === numTriangles * 3) {\n            var newColors = [];\n            for (var i = 0; i < numTriangles; i++) {\n              var r = colors[3 * i + 0];\n              var g = colors[3 * i + 1];\n              var b = colors[3 * i + 2];\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n            }\n            geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n          }\n        }\n        return geometry;\n      }\n      function parseBinary(data) {\n        var count, pointIndex, i, numberOfPoints, s;\n        var buffer = new Uint8Array(data);\n        var dataView = new DataView(data); // Points and normals, by default, are empty\n\n        var points = [];\n        var normals = [];\n        var indices = []; // Going to make a big array of strings\n        var index = 0;\n        function findString(buffer, start) {\n          var index = start;\n          var c = buffer[index];\n          var s = [];\n          while (c !== 10) {\n            s.push(String.fromCharCode(c));\n            index++;\n            c = buffer[index];\n          }\n          return {\n            start: start,\n            end: index,\n            next: index + 1,\n            parsedString: s.join('')\n          };\n        }\n        var state, line;\n        while (true) {\n          // Get a string\n          state = findString(buffer, index);\n          line = state.parsedString;\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (line.indexOf('POINTS') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n            count = numberOfPoints * 4 * 3;\n            points = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n            for (i = 0; i < numberOfPoints; i++) {\n              points[3 * i] = dataView.getFloat32(pointIndex, false);\n              points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex = pointIndex + 12;\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // retrieves the n-2 triangles from the triangle strip\n\n              for (var j = 0; j < indexCount - 2; j++) {\n                if (j % 2) {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 2];\n                  indices[indicesIndex++] = strip[j + 1];\n                } else {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 1];\n                  indices[indicesIndex++] = strip[j + 2];\n                }\n              }\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POLYGONS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // divide the polygon in n-2 triangle\n\n              for (var j = 1; j < indexCount - 1; j++) {\n                indices[indicesIndex++] = strip[0];\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n              }\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POINT_DATA') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n            state = findString(buffer, state.next); // Now grab the binary data\n\n            count = numberOfPoints * 4 * 3;\n            normals = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n            for (i = 0; i < numberOfPoints; i++) {\n              normals[3 * i] = dataView.getFloat32(pointIndex, false);\n              normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex += 12;\n            } // Increment past our data\n\n            state.next = state.next + count;\n          } // Increment index\n\n          index = state.next;\n          if (index >= buffer.byteLength) {\n            break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      }\n      function Float32Concat(first, second) {\n        var firstLength = first.length,\n          result = new Float32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n      function Int32Concat(first, second) {\n        var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n      function parseXML(stringFile) {\n        // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n        function xmlToJson(xml) {\n          // Create the return object\n          var obj = {};\n          if (xml.nodeType === 1) {\n            // element\n            // do attributes\n            if (xml.attributes) {\n              if (xml.attributes.length > 0) {\n                obj['attributes'] = {};\n                for (var j = 0; j < xml.attributes.length; j++) {\n                  var attribute = xml.attributes.item(j);\n                  obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n                }\n              }\n            }\n          } else if (xml.nodeType === 3) {\n            // text\n            obj = xml.nodeValue.trim();\n          } // do children\n\n          if (xml.hasChildNodes()) {\n            for (var i = 0; i < xml.childNodes.length; i++) {\n              var item = xml.childNodes.item(i);\n              var nodeName = item.nodeName;\n              if (typeof obj[nodeName] === 'undefined') {\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName] = tmp;\n              } else {\n                if (typeof obj[nodeName].push === 'undefined') {\n                  var old = obj[nodeName];\n                  obj[nodeName] = [old];\n                }\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName].push(tmp);\n              }\n            }\n          }\n          return obj;\n        } // Taken from Base64-js\n\n        function Base64toByteArray(b64) {\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          var i;\n          var lookup = [];\n          var revLookup = [];\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n          var len = code.length;\n          for (i = 0; i < len; i++) {\n            lookup[i] = code[i];\n          }\n          for (i = 0; i < len; ++i) {\n            revLookup[code.charCodeAt(i)] = i;\n          }\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n          var j, l, tmp, placeHolders, arr;\n          var len = b64.length;\n          if (len % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n          arr = new Arr(len * 3 / 4 - placeHolders);\n          l = placeHolders > 0 ? len - 4 : len;\n          var L = 0;\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n            arr[L++] = (tmp & 0xff0000) >> 16;\n            arr[L++] = (tmp & 0xff00) >> 8;\n            arr[L++] = tmp & 0xff;\n          }\n          if (placeHolders === 2) {\n            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n            arr[L++] = tmp & 0xff;\n          } else if (placeHolders === 1) {\n            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n            arr[L++] = tmp >> 8 & 0xff;\n            arr[L++] = tmp & 0xff;\n          }\n          return arr;\n        }\n        function parseDataArray(ele, compressed) {\n          var numBytes = 0;\n          if (json.attributes.header_type === 'UInt64') {\n            numBytes = 8;\n          } else if (json.attributes.header_type === 'UInt32') {\n            numBytes = 4;\n          } // Check the format\n\n          if (ele.attributes.format === 'binary' && compressed) {\n            var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array();\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array();\n            } // VTP data with the header has the following structure:\n            // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n            //\n            // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n            // [#blocks] = Number of blocks\n            // [#u-size] = Block size before compression\n            // [#p-size] = Size of last partial block (zero if it not needed)\n            // [#c-size-i] = Size in bytes of block i after compression\n            //\n            // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n            // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n            rawData = ele['#text'];\n            byteData = Base64toByteArray(rawData);\n            blocks = byteData[0];\n            for (var i = 1; i < numBytes - 1; i++) {\n              blocks = blocks | byteData[i] << i * numBytes;\n            }\n            headerSize = (blocks + 3) * numBytes;\n            padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n            headerSize = headerSize + padding;\n            dataOffsets = [];\n            currentOffset = headerSize;\n            dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n            // There are three blocks before c-size-i, so we skip 3*numBytes\n\n            cSizeStart = 3 * numBytes;\n            for (var i = 0; i < blocks; i++) {\n              var currentBlockSize = byteData[i * numBytes + cSizeStart];\n              for (var j = 1; j < numBytes - 1; j++) {\n                // Each data point consists of 8 bytes regardless of the header type\n                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n              }\n              currentOffset = currentOffset + currentBlockSize;\n              dataOffsets.push(currentOffset);\n            }\n            for (var i = 0; i < dataOffsets.length - 1; i++) {\n              var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n              content = data.buffer;\n              if (ele.attributes.type === 'Float32') {\n                content = new Float32Array(content);\n                txt = Float32Concat(txt, content);\n              } else if (ele.attributes.type === 'Int64') {\n                content = new Int32Array(content);\n                txt = Int32Concat(txt, content);\n              }\n            }\n            delete ele['#text'];\n            if (ele.attributes.type === 'Int64') {\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } else {\n            if (ele.attributes.format === 'binary' && !compressed) {\n              var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n              // [#bytes][DATA]\n              // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n              content = content.slice(numBytes).buffer;\n            } else {\n              if (ele['#text']) {\n                var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                  if (el !== '') return el;\n                });\n              } else {\n                var content = new Int32Array(0).buffer;\n              }\n            }\n            delete ele['#text']; // Get the content and optimize it\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array(content);\n            } else if (ele.attributes.type === 'Int32') {\n              var txt = new Int32Array(content);\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array(content);\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } // endif ( ele.attributes.format === 'binary' && compressed )\n\n          return txt;\n        } // Main part\n        // Get Dom\n\n        var dom = null;\n        if (window.DOMParser) {\n          try {\n            dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n          } catch (e) {\n            dom = null;\n          }\n        } else if (window.ActiveXObject) {\n          try {\n            dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n            dom.async = false;\n            if (!dom.loadXML()) {\n              throw new Error(dom.parseError.reason + dom.parseError.srcText);\n            }\n          } catch (e) {\n            dom = null;\n          }\n        } else {\n          throw new Error('Cannot parse xml string!');\n        } // Get the doc\n\n        var doc = dom.documentElement; // Convert to json\n\n        var json = xmlToJson(doc);\n        var points = [];\n        var normals = [];\n        var indices = [];\n        if (json.PolyData) {\n          var piece = json.PolyData.Piece;\n          var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n          // Loop through the sections\n\n          var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n          var sectionIndex = 0,\n            numberOfSections = sections.length;\n          while (sectionIndex < numberOfSections) {\n            var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n            if (section && section.DataArray) {\n              // Depending on the number of DataArrays\n              if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n                var arr = section.DataArray;\n              } else {\n                var arr = [section.DataArray];\n              }\n              var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n              while (dataArrayIndex < numberOfDataArrays) {\n                // Parse the DataArray\n                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                  arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n                }\n                dataArrayIndex++;\n              }\n              switch (sections[sectionIndex]) {\n                // if iti is point data\n                case 'PointData':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  var normalsName = section.attributes.Normals;\n                  if (numberOfPoints > 0) {\n                    for (var i = 0, len = arr.length; i < len; i++) {\n                      if (normalsName === arr[i].attributes.Name) {\n                        var components = arr[i].attributes.NumberOfComponents;\n                        normals = new Float32Array(numberOfPoints * components);\n                        normals.set(arr[i].text, 0);\n                      }\n                    }\n                  }\n                  break;\n                // if it is points\n\n                case 'Points':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  if (numberOfPoints > 0) {\n                    var components = section.DataArray.attributes.NumberOfComponents;\n                    points = new Float32Array(numberOfPoints * components);\n                    points.set(section.DataArray.text, 0);\n                  }\n                  break;\n                // if it is strips\n\n                case 'Strips':\n                  var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                  if (numberOfStrips > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfStrips + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                    var indicesIndex = 0;\n                    for (var i = 0, len = numberOfStrips; i < len; i++) {\n                      var strip = [];\n                      for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                        strip.push(connectivity[s]);\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                      for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                        if (j % 2) {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 2];\n                          indices[indicesIndex++] = strip[j + 1];\n                        } else {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 1];\n                          indices[indicesIndex++] = strip[j + 2];\n                        }\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                    }\n                  }\n                  break;\n                // if it is polys\n\n                case 'Polys':\n                  var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                  if (numberOfPolys > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfPolys + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                    var indicesIndex = 0,\n                      connectivityIndex = 0;\n                    var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n                    while (i < len) {\n                      var poly = [];\n                      var s = 0,\n                        len1 = offset[i];\n                      while (s < len1 - len0) {\n                        poly.push(connectivity[connectivityIndex++]);\n                        s++;\n                      }\n                      var j = 1;\n                      while (j < len1 - len0 - 1) {\n                        indices[indicesIndex++] = poly[0];\n                        indices[indicesIndex++] = poly[j];\n                        indices[indicesIndex++] = poly[j + 1];\n                        j++;\n                      }\n                      i++;\n                      len0 = offset[i - 1];\n                    }\n                  }\n                  break;\n              }\n            }\n            sectionIndex++;\n          }\n          var geometry = new BufferGeometry();\n          geometry.setIndex(new BufferAttribute(indices, 1));\n          geometry.setAttribute('position', new BufferAttribute(points, 3));\n          if (normals.length === points.length) {\n            geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n          }\n          return geometry;\n        } else {\n          throw new Error('Unsupported DATASET type');\n        }\n      } // get the 5 first lines of the files to check if there is the key word binary\n\n      var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n      if (meta[0].indexOf('xml') !== -1) {\n        return parseXML(LoaderUtils.decodeText(data));\n      } else if (meta[2].includes('ASCII')) {\n        return parseASCII(LoaderUtils.decodeText(data));\n      } else {\n        return parseBinary(data);\n      }\n    }\n  }]);\n  return VTKLoader;\n}(Loader);\nexport { VTKLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","BufferAttribute","unzlibSync","VTKLoader","manager","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","data","parseASCII","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","i1","i2","k","j","r","g","b","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","pointIndex","numberOfPoints","s","buffer","Uint8Array","dataView","DataView","points","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","state","Float32Array","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","old","Base64toByteArray","b64","Arr","Array","lookup","revLookup","code","len","charCodeAt","l","placeHolders","arr","L","parseDataArray","ele","compressed","numBytes","json","header_type","format","rawData","content","byteData","blocks","cSizeStart","headerSize","padding","dataOffsets","currentOffset","type","txt","currentBlockSize","slice","filter","el","idx","dom","window","DOMParser","parseFromString","ActiveXObject","async","loadXML","parseError","reason","srcText","doc","documentElement","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","Object","prototype","toString","call","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","NumberOfStrips","connectivity","offset","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","meta","decodeText","includes"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/loaders/VTKLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\n\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []; // triangles vertices\n\n      var positions = []; // red, green, blue colors in the range 0 to 1\n\n      var colors = []; // normal vector, one per vertex\n\n      var normals = [];\n      var result; // pattern for detecting the end of a number sequence\n\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data.split('\\n');\n\n      for (var i in lines) {\n        var line = lines[i].trim();\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n\n      if (colors.length !== indices.length) {\n        // stagger\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n\n      return geometry;\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data); // Points and normals, by default, are empty\n\n      var points = [];\n      var normals = [];\n      var indices = []; // Going to make a big array of strings\n      var index = 0;\n\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n\n      var state, line;\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // retrieves the n-2 triangles from the triangle strip\n\n\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // divide the polygon in n-2 triangle\n\n\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n          state = findString(buffer, state.next); // Now grab the binary data\n\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          } // Increment past our data\n\n\n          state.next = state.next + count;\n        } // Increment index\n\n\n        index = state.next;\n\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n\n      return geometry;\n    }\n\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n            result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n\n              for (var j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        } // do children\n\n\n        if (xml.hasChildNodes()) {\n          for (var i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i);\n            var nodeName = item.nodeName;\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n\n        return obj;\n      } // Taken from Base64-js\n\n\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xff0000) >> 16;\n          arr[L++] = (tmp & 0xff00) >> 8;\n          arr[L++] = tmp & 0xff;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xff;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xff;\n          arr[L++] = tmp & 0xff;\n        }\n\n        return arr;\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        } // Check the format\n\n\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          } // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n          rawData = ele['#text'];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n\n          for (var i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * numBytes;\n          }\n\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n\n          cSizeStart = 3 * numBytes;\n\n          for (var i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n            for (var j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n            }\n\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n            content = data.buffer;\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n\n          delete ele['#text'];\n\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n\n          delete ele['#text']; // Get the content and optimize it\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n        return txt;\n      } // Main part\n      // Get Dom\n\n\n      var dom = null;\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n          dom.async = false;\n\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      } // Get the doc\n\n\n      var doc = dom.documentElement; // Convert to json\n\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n        // Loop through the sections\n\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n        var sectionIndex = 0,\n            numberOfSections = sections.length;\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n\n            var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n\n              dataArrayIndex++;\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n\n                break;\n              // if it is points\n\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n\n                break;\n              // if it is strips\n\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n\n                break;\n              // if it is polys\n\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                      connectivityIndex = 0;\n                  var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                        len1 = offset[i];\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n\n                    var j = 1;\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n\n                break;\n            }\n          }\n\n          sectionIndex++;\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    } // get the 5 first lines of the files to check if there is the key word binary\n\n\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n\n}\n\nexport { VTKLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}