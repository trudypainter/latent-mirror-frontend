{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n  var _super = _createSuper(EXRLoader);\n  function EXRLoader(manager) {\n    var _this;\n    _classCallCheck(this, EXRLoader);\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  }\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16; // literal (value) bit length\n\n      var HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n      var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n        var n = k - 1;\n        while (k < USHORT_RANGE) {\n          lut[k++] = 0;\n        }\n        return n;\n      }\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n      function getBits(nBits, c, lc, uInt8Array, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n          lc += 8;\n        }\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n      var hufTableBuffer = new Array(59);\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) {\n          hufTableBuffer[i] = 0;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          hufTableBuffer[hcode[i]] += 1;\n        }\n        var c = 0;\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n      function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            getBits(8, c, lc, uInt8Array, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n            im--;\n          }\n        }\n        hufCanonicalCodeTable(hcode);\n      }\n      function hufLength(code) {\n        return code & 63;\n      }\n      function hufCode(code) {\n        return code >> 6;\n      }\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n          if (c >> l) {\n            throw 'Invalid table entry';\n          }\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n            if (pl.len) {\n              throw 'Invalid table entry';\n            }\n            pl.lit++;\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n              if (pl.len || pl.p) {\n                throw 'Invalid table entry';\n              }\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n        return true;\n      }\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getChar(c, lc, uInt8Array, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n          var s = outBuffer[outBufferOffset.value - 1];\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n      function UInt16(value) {\n        return value & 0xffff;\n      }\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 0x7fff ? ref - 0x10000 : ref;\n      }\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n      function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n        while (p <= n) {\n          p <<= 1;\n        }\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n              if (w14) {\n                wdec14(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              }\n            }\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer[p10 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          p2 = p;\n          p >>= 1;\n        }\n        return py;\n      }\n      function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw 'hufDecode issues';\n              }\n              var j;\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n              if (j == pl.lit) {\n                throw 'hufDecode issues';\n              }\n            }\n          }\n        }\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw 'hufDecode issues';\n          }\n        }\n        return true;\n      }\n      function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw 'Something wrong with HUF_ENCSIZE';\n        }\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw 'Something wrong with hufUncompress';\n        }\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n        return out;\n      }\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8.0);\n        var numBlocksX = Math.ceil(width / 8.0);\n        var numBlocksY = Math.ceil(height / 8.0);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n        for (var _comp = 0; _comp < numComp; ++_comp) {\n          rowOffsets[_comp] = rowPtrs[cscSet.idx[_comp]];\n          currDcComp[_comp] = _comp < 1 ? 0 : currDcComp[_comp - 1] + numBlocksX * numBlocksY;\n          dctData[_comp] = new Float32Array(64);\n          halfZigBlock[_comp] = new Uint16Array(64);\n          rowBlock[_comp] = new Uint16Array(numBlocksX * 64);\n        }\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              halfZigBlock[_comp2].fill(0); // set block DC component\n\n              halfZigBlock[_comp2][0] = dcBuffer[currDcComp[_comp2]++]; // set block AC components\n\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp2]); // UnZigZag block to float\n\n              unZigZag(halfZigBlock[_comp2], dctData[_comp2]); // decode float dct\n\n              dctInverse(dctData[_comp2]);\n            }\n            {\n              csc709Inverse(dctData);\n            }\n            for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n              convertToHalf(dctData[_comp3], rowBlock[_comp3], blockx * 64);\n            }\n          } // blockx\n\n          var _offset = 0;\n          for (var _comp4 = 0; _comp4 < numComp; ++_comp4) {\n            var _type = channelData[cscSet.idx[_comp4]].type;\n            for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n              _offset = rowOffsets[_comp4][_y];\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (_y & 0x7) * 8;\n                dataView.setUint16(_offset + 0 * INT16_SIZE * _type, rowBlock[_comp4][src + 0], true);\n                dataView.setUint16(_offset + 1 * INT16_SIZE * _type, rowBlock[_comp4][src + 1], true);\n                dataView.setUint16(_offset + 2 * INT16_SIZE * _type, rowBlock[_comp4][src + 2], true);\n                dataView.setUint16(_offset + 3 * INT16_SIZE * _type, rowBlock[_comp4][src + 3], true);\n                dataView.setUint16(_offset + 4 * INT16_SIZE * _type, rowBlock[_comp4][src + 4], true);\n                dataView.setUint16(_offset + 5 * INT16_SIZE * _type, rowBlock[_comp4][src + 5], true);\n                dataView.setUint16(_offset + 6 * INT16_SIZE * _type, rowBlock[_comp4][src + 6], true);\n                dataView.setUint16(_offset + 7 * INT16_SIZE * _type, rowBlock[_comp4][src + 7], true);\n                _offset += 8 * INT16_SIZE * _type;\n              }\n            } // handle partial X blocks\n\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y2 = 8 * blocky; _y2 < 8 * blocky + maxY; ++_y2) {\n                var _offset2 = rowOffsets[_comp4][_y2] + 8 * numFullBlocksX * INT16_SIZE * _type;\n                var _src = numFullBlocksX * 64 + (_y2 & 0x7) * 8;\n                for (var _x = 0; _x < maxX; ++_x) {\n                  dataView.setUint16(_offset2 + _x * INT16_SIZE * _type, rowBlock[_comp4][_src + _x], true);\n                }\n              }\n            }\n          } // comp\n        } // blocky\n\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n          for (var y = 0; y < height; ++y) {\n            var _offset3 = rowOffsets[comp][y];\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset3 + x * INT16_SIZE * type, true);\n            }\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset3 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n          if (acValue == 0xff00) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 0xff) {\n            dctComp += acValue & 0xff;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n          currAcComp.value++;\n        }\n      }\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4.0);\n        var b = 0.5 * Math.cos(3.14159 / 16.0);\n        var c = 0.5 * Math.cos(3.14159 / 8.0);\n        var d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n        var e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n        var f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n        var g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n        }\n      }\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i]['start'] = outBufferEnd;\n          pizChannelData[i]['end'] = pizChannelData[i]['start'];\n          pizChannelData[i]['nx'] = info.width;\n          pizChannelData[i]['ny'] = info.lines;\n          pizChannelData[i]['size'] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        } // Read range compression data\n\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n        }\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        } // Reverse LUT\n\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        } // Expand the pixel data to their original range\n\n        applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n        var tmpOffset = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset);\n            tmpOffset += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n            }\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n        if (dwaHeader.version < 2) {\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n        } // Read channel ruleset information\n\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        } // Classify channels\n\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n        var cscSet = {\n          idx: new Array(3)\n        };\n        for (var offset = 0; offset < info.channels; ++offset) {\n          var cd = channelData[offset];\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset;\n              }\n              cd.offset = offset;\n            }\n          }\n        } // Read DCT - AC component data\n\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        } // Read DCT - DC component data\n\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        } // Read RLE compressed data\n\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        } // Prepare outbuffer data offset\n\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        } // Lossy DCT decode RGB channels\n\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n                  rleOffset++;\n                }\n                row++;\n              }\n              break;\n            case LOSSY_DCT: // skip\n\n            default:\n              throw 'EXRLoader.parse: unsupported channel compression';\n          }\n        }\n        return new DataView(outBuffer.buffer);\n      }\n      function parseNullTerminatedString(buffer, offset) {\n        var uintBuffer = new Uint8Array(buffer);\n        var endOffset = 0;\n        while (uintBuffer[offset.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n        offset.value = offset.value + endOffset + 1;\n        return stringValue;\n      }\n      function parseFixedLengthString(buffer, offset, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n        offset.value = offset.value + size;\n        return stringValue;\n      }\n      function parseRational(dataView, offset) {\n        var x = parseInt32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseTimecode(dataView, offset) {\n        var x = parseUint32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseInt32(dataView, offset) {\n        var Int32 = dataView.getInt32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Int32;\n      }\n      function parseUint32(dataView, offset) {\n        var Uint32 = dataView.getUint32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Uint32;\n      }\n      function parseUint8Array(uInt8Array, offset) {\n        var Uint8 = uInt8Array[offset.value];\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      function parseUint8(dataView, offset) {\n        var Uint8 = dataView.getUint8(offset.value);\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      var parseInt64 = function parseInt64(dataView, offset) {\n        var int;\n        if ('getBigInt64' in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset.value, true));\n        } else {\n          int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n        }\n        offset.value += ULONG_SIZE;\n        return int;\n      };\n      function parseFloat32(dataView, offset) {\n        var float = dataView.getFloat32(offset.value, true);\n        offset.value += FLOAT32_SIZE;\n        return float;\n      }\n      function decodeFloat32(dataView, offset) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n      } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n      function decodeFloat16(binary) {\n        var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n      }\n      function parseUint16(dataView, offset) {\n        var Uint16 = dataView.getUint16(offset.value, true);\n        offset.value += INT16_SIZE;\n        return Uint16;\n      }\n      function parseFloat16(buffer, offset) {\n        return decodeFloat16(parseUint16(buffer, offset));\n      }\n      function parseChlist(dataView, buffer, offset, size) {\n        var startOffset = offset.value;\n        var channels = [];\n        while (offset.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer, offset);\n          var pixelType = parseInt32(dataView, offset);\n          var pLinear = parseUint8(dataView, offset);\n          offset.value += 3; // reserved, three chars\n\n          var xSampling = parseInt32(dataView, offset);\n          var ySampling = parseInt32(dataView, offset);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n        offset.value += 1;\n        return channels;\n      }\n      function parseChromaticities(dataView, offset) {\n        var redX = parseFloat32(dataView, offset);\n        var redY = parseFloat32(dataView, offset);\n        var greenX = parseFloat32(dataView, offset);\n        var greenY = parseFloat32(dataView, offset);\n        var blueX = parseFloat32(dataView, offset);\n        var blueY = parseFloat32(dataView, offset);\n        var whiteX = parseFloat32(dataView, offset);\n        var whiteY = parseFloat32(dataView, offset);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n      function parseCompression(dataView, offset) {\n        var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n        var compression = parseUint8(dataView, offset);\n        return compressionCodes[compression];\n      }\n      function parseBox2i(dataView, offset) {\n        var xMin = parseUint32(dataView, offset);\n        var yMin = parseUint32(dataView, offset);\n        var xMax = parseUint32(dataView, offset);\n        var yMax = parseUint32(dataView, offset);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n      function parseLineOrder(dataView, offset) {\n        var lineOrders = ['INCREASING_Y'];\n        var lineOrder = parseUint8(dataView, offset);\n        return lineOrders[lineOrder];\n      }\n      function parseV2f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        return [x, y];\n      }\n      function parseV3f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        var z = parseFloat32(dataView, offset);\n        return [x, y, z];\n      }\n      function parseValue(dataView, buffer, offset, type, size) {\n        if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n          return parseFixedLengthString(buffer, offset, size);\n        } else if (type === 'chlist') {\n          return parseChlist(dataView, buffer, offset, size);\n        } else if (type === 'chromaticities') {\n          return parseChromaticities(dataView, offset);\n        } else if (type === 'compression') {\n          return parseCompression(dataView, offset);\n        } else if (type === 'box2i') {\n          return parseBox2i(dataView, offset);\n        } else if (type === 'lineOrder') {\n          return parseLineOrder(dataView, offset);\n        } else if (type === 'float') {\n          return parseFloat32(dataView, offset);\n        } else if (type === 'v2f') {\n          return parseV2f(dataView, offset);\n        } else if (type === 'v3f') {\n          return parseV3f(dataView, offset);\n        } else if (type === 'int') {\n          return parseInt32(dataView, offset);\n        } else if (type === 'rational') {\n          return parseRational(dataView, offset);\n        } else if (type === 'timecode') {\n          return parseTimecode(dataView, offset);\n        } else if (type === 'preview') {\n          offset.value += size;\n          return 'skipped';\n        } else {\n          offset.value += size;\n          return undefined;\n        }\n      }\n      function parseHeader(dataView, buffer, offset) {\n        var EXRHeader = {};\n        if (dataView.getUint32(0, true) != 20000630) {\n          // magic\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n        EXRHeader.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5); // fullMask\n\n        EXRHeader.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        }; // start of header\n\n        offset.value = 8; // start at 8 - after pre-amble\n\n        var keepReading = true;\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer, offset);\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer, offset);\n            var attributeSize = parseUint32(dataView, offset);\n            var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n            if (attributeValue === undefined) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader[attributeName] = attributeValue;\n            }\n          }\n        }\n        if (spec != 0) {\n          console.error('EXRHeader:', EXRHeader);\n          throw 'THREE.EXRLoader: provided file is currently unsupported.';\n        }\n        return EXRHeader;\n      }\n      function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n        var EXRDecoder = {\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array,\n          offset: offset,\n          width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n          height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n          channels: EXRHeader.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null,\n          encoding: null\n        };\n        switch (EXRHeader.compression) {\n          case 'NO_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRAW;\n            break;\n          case 'RLE_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRLE;\n            break;\n          case 'ZIPS_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'ZIP_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'PIZ_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressPIZ;\n            break;\n          case 'PXR24_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressPXR;\n            break;\n          case 'DWAA_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          case 'DWAB_COMPRESSION':\n            EXRDecoder.lines = 256;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          default:\n            throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n        }\n        EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n        if (EXRDecoder.type == 1) {\n          // half\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = parseUint16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder.type == 2) {\n          // float\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = decodeFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n        }\n        EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n        for (var i = 0; i < EXRDecoder.blockCount; i++) {\n          parseInt64(dataView, offset);\n        } // scanlineOffset\n        // we should be passed the scanline offset table, ready to start reading pixel data.\n        // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n        EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n        var size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n            break;\n          case HalfFloatType:\n            EXRDecoder.byteArray = new Uint16Array(size);\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n            break;\n          default:\n            console.error('THREE.EXRLoader: unsupported type: ', outputType);\n            break;\n        }\n        EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n        if (EXRDecoder.outputChannels == 4) {\n          EXRDecoder.format = RGBAFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        } else {\n          EXRDecoder.format = RedFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        }\n        return EXRDecoder;\n      } // start parsing file [START]\n\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      }; // get header information and validate format.\n\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset); // line_no\n\n        EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n      return {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format,\n        encoding: EXRDecoder.encoding,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n  return EXRLoader;\n}(DataTextureLoader);\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","HalfFloatType","FloatType","RGBAFormat","LinearEncoding","RedFormat","LinearFilter","DataUtils","unzlibSync","EXRLoader","manager","type","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","value","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","undefined","parseHeader","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","error","setupDecoder","outputType","EXRDecoder","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","encoding","blockCount","outputChannels","byteArray","bufferDataView","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/loaders/EXRLoader.js"],"sourcesContent":["import { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n\n        let offset = 0;\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n      } // Read channel ruleset information\n\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int;\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true));\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n      }\n\n      offset.value += ULONG_SIZE;\n      return int;\n    };\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {};\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n\n      EXRHeader.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5); // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      }; // start of header\n\n      offset.value = 8; // start at 8 - after pre-amble\n\n      var keepReading = true;\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset);\n\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset);\n          var attributeSize = parseUint32(dataView, offset);\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n          } else {\n            EXRHeader[attributeName] = attributeValue;\n          }\n        }\n      }\n\n      if (spec != 0) {\n        console.error('EXRHeader:', EXRHeader);\n        throw 'THREE.EXRLoader: provided file is currently unsupported.';\n      }\n\n      return EXRHeader;\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRAW;\n          break;\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRLE;\n          break;\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressPIZ;\n          break;\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressPXR;\n          break;\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset); // scanlineOffset\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n          break;\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size);\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n          break;\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType);\n          break;\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n\n      if (EXRDecoder.outputChannels == 4) {\n        EXRDecoder.format = RGBAFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      } else {\n        EXRDecoder.format = RedFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      }\n\n      return EXRDecoder;\n    } // start parsing file [START]\n\n\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    }; // get header information and validate format.\n\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset); // line_no\n\n      EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { EXRLoader };\n"],"mappings":"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,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,E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"},"metadata":{},"sourceType":"module"}