{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n    /**\n     * Static utility functions\n     */\n  }]);\n  return GLTFExporter;\n}(); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 0.001; // 1ms\n\n    var valueSize = track.getValueSize(); // @ts-expect-error\n\n    var times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i = 0; _i < track.times.length; _i++) {\n        if (Math.abs(track.times[_i] - time) < tolerance) return _i;\n        if (track.times[_i] < time && track.times[_i + 1] > time) {\n          times.set(track.times.slice(0, _i + 1), 0);\n          times[_i + 1] = time;\n          times.set(track.times.slice(_i + 1), _i + 2);\n          values.set(track.values.slice(0, (_i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i + 1) * valueSize);\n          values.set(track.values.slice((_i + 1) * valueSize), (_i + 2) * valueSize);\n          index = _i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (\n      // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n      // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n});\nvar WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 0x46546c67;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    _defineProperty(this, \"plugins\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"pending\", void 0);\n    _defineProperty(this, \"buffers\", void 0);\n    _defineProperty(this, \"byteOffset\", void 0);\n    _defineProperty(this, \"nodeMap\", void 0);\n    _defineProperty(this, \"skins\", void 0);\n    _defineProperty(this, \"extensionsUsed\", void 0);\n    _defineProperty(this, \"uids\", void 0);\n    _defineProperty(this, \"uid\", void 0);\n    _defineProperty(this, \"json\", void 0);\n    _defineProperty(this, \"cache\", void 0);\n    _defineProperty(this, \"cachedCanvas\", void 0);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function write(input, onDone, options) {\n      var _this = this;\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n      if (this.options.animations !== undefined && this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n      this.processInput(input);\n      var writer = this;\n      Promise.all(this.pending).then(function () {\n        var buffers = writer.buffers;\n        var json = writer.json;\n        var options = writer.options;\n        var extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        var blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        var extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n        if (options.binary) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n          reader.onloadend = function () {\n            if (reader.result !== null && typeof reader.result !== 'string') {\n              // Binary chunk.\n              var binaryChunk = _this.getPaddedArrayBuffer(reader.result);\n              var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n              binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n              var jsonChunk = _this.getPaddedArrayBuffer(_this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n              var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n              jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n              var header = new ArrayBuffer(GLB_HEADER_BYTES);\n              var headerView = new DataView(header);\n              headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n              headerView.setUint32(4, GLB_VERSION, true);\n              var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n              headerView.setUint32(8, totalByteLength, true);\n              var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                type: 'application/octet-stream'\n              });\n              var glbReader = new window.FileReader();\n              glbReader.readAsArrayBuffer(glbBlob);\n              glbReader.onloadend = function () {\n                if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                  onDone(glbReader.result);\n                }\n              };\n            }\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var _reader = new window.FileReader();\n            _reader.readAsDataURL(blob);\n            _reader.onloadend = function () {\n              var base64data = _reader.result;\n              if (json.buffers !== undefined && base64data !== null) {\n                json.buffers[0].uri = base64data;\n                onDone(json);\n              }\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    }\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        if (error instanceof Error) {\n          console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n        }\n      }\n    }\n    /**\n     * Assign and return a temporal unique id for an object\n     * especially which doesn't have .uuid\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      var componentSize;\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n      var byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (value !== undefined) {\n            if (componentType === WEBGL_CONSTANTS.FLOAT) {\n              dataView.setFloat32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n              dataView.setUint32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n              dataView.setUint16(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n              dataView.setUint8(offset, value);\n            }\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var _this2 = this;\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = function () {\n          if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n            var buffer = _this2.getPaddedArrayBuffer(reader.result);\n            var bufferViewDef = {\n              buffer: writer.processBuffer(buffer),\n              byteOffset: writer.byteOffset,\n              byteLength: buffer.byteLength\n            };\n            writer.byteOffset += buffer.byteLength;\n            resolve(json.bufferViews.push(bufferViewDef) - 1);\n          }\n        };\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var options = this.options;\n      var json = this.json;\n      var types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      var componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        var end = start + count;\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n      if (count === 0) return null;\n      var minMax = this.getMinMax(attribute, start, count);\n      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      if (bufferViewTarget !== undefined) {\n        var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n        var accessorDef = {\n          bufferView: bufferView.id,\n          byteOffset: bufferView.byteOffset,\n          componentType: componentType,\n          count: count,\n          max: minMax.max,\n          min: minMax.min,\n          type: types[attribute.itemSize]\n        };\n        if (attribute.normalized) accessorDef.normalized = true;\n        if (!json.accessors) json.accessors = [];\n        return json.accessors.push(accessorDef) - 1;\n      }\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var writer = this;\n      var cache = writer.cache;\n      var json = writer.json;\n      var options = writer.options;\n      var pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      var cachedImages = cache.images.get(image);\n      var mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      var key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      var imageDef = {\n        mimeType: mimeType\n      };\n      if (options.embedImages && options.maxTextureSize !== undefined) {\n        var canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext('2d');\n        if (flipY) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n          ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n        }\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat) {\n            console.error('GLTFExporter: Only RGBA format is supported.');\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n          if (image instanceof ImageData) {\n            for (var i = 0; i < data.length; i += 4) {\n              data[i + 0] = image.data[i + 0];\n              data[i + 1] = image.data[i + 1];\n              data[i + 2] = image.data[i + 2];\n              data[i + 3] = image.data[i + 3];\n            }\n          }\n          ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n        if (options.binary) {\n          pending.push(new Promise(function (resolve) {\n            canvas.toBlob(function (blob) {\n              if (blob !== null) {\n                writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                  imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                  resolve();\n                });\n              }\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else if (image instanceof Image) {\n        imageDef.uri = image.src;\n      }\n      var index = json.images.push(imageDef) - 1;\n      if (cachedImages !== undefined) cachedImages[key] = index;\n      return index;\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial &&\n      // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      }\n      if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n        // pbrMetallicRoughness.baseColorFactor\n        var color = material.color.toArray().concat([material.opacity]);\n        if (!this.equalArray(color, [1, 1, 1, 1])) {\n          materialDef.pbrMetallicRoughness.baseColorFactor = color;\n        }\n      }\n      if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n      if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n          var metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n        // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 1) {\n          emissive.multiplyScalar(1 / maxEmissiveComponent);\n          console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n        }\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = emissive.toArray();\n        } // emissiveTexture\n\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n      if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n          // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode; // Use the correct mode\n\n      if (mesh instanceof LineSegments && mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh instanceof Line && mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh instanceof Points && mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      var nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      var originalNormal = geometry.getAttribute('normal');\n      if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n            var gltfAttributeName = _attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute));\n              continue;\n            } // Clones attribute not to override\n\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, _attribute.getX(j) - baseAttribute.getX(j), _attribute.getY(j) - baseAttribute.getY(j), _attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n            var _accessor = this.processAccessor(relativeAttribute, geometry);\n            if (_accessor != undefined) {\n              target[gltfAttributeName] = _accessor;\n            }\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i2]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        if (geometry instanceof Object3D || geometry instanceof Material) {\n          this.serializeUserData(geometry, primitive);\n        }\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i3].start !== undefined || groups[_i3].count !== undefined) {\n            // @ts-expect-error\n            cacheKey += \":\".concat(groups[_i3].start, \":\").concat(groups[_i3].count);\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var materialIndex = groups[_i3].materialIndex;\n        if (materialIndex !== undefined && Array.isArray(materials)) {\n          var targetMaterials = materials[materialIndex];\n          if (!Array.isArray(targetMaterials)) {\n            var material = this.processMaterial(targetMaterials);\n            if (material !== null) primitive.material = material;\n            primitives.push(primitive);\n          }\n        }\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n      if (camera instanceof OrthographicCamera && isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else if (camera instanceof PerspectiveCamera) {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n        // @ts-expect-error\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || 'clip_' + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n        var node = json.nodes[nodeMap.get(object)];\n        var skeleton = object.skeleton;\n        if (skeleton === undefined) return null;\n        var rootJoint = object.skeleton.bones[0];\n        if (rootJoint === undefined) return null;\n        var joints = [];\n        var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n        var temporaryBoneInverse = new Matrix4();\n        for (var i = 0; i < skeleton.bones.length; ++i) {\n          joints.push(nodeMap.get(skeleton.bones[i]));\n          temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n          temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n        }\n        if (json.skins === undefined) json.skins = [];\n        json.skins.push({\n          inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n          joints: joints,\n          skeleton: nodeMap.get(rootJoint)\n        });\n        var skinIndex = node.skin = json.skins.length - 1;\n        return skinIndex;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!this.equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!this.equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (!this.isIdentityMatrix(object.matrix)) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object instanceof Camera && object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || !options.onlyVisible) {\n            var _nodeIndex = this.processNode(child);\n            if (_nodeIndex !== null) children.push(_nodeIndex);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || !options.onlyVisible) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = 'AuxScene';\n      for (var i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        var inputScene = input[i];\n        if (inputScene instanceof Scene) {\n          this.processScene(inputScene);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n      for (var _i5 = 0; options.animations !== undefined && _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    } //------------------------------------------------------------------------------\n    // Utility functions\n    //------------------------------------------------------------------------------\n\n    /**\n     * Compare two arrays\n     * @param  {Array} array1 Array 1 to compare\n     * @param  {Array} array2 Array 2 to compare\n     * @return {Boolean}        Returns true if both arrays are equal\n     */\n  }, {\n    key: \"equalArray\",\n    value: function equalArray(array1, array2) {\n      return array1.length === array2.length && array1.every(function (element, index) {\n        return element === array2[index];\n      });\n    }\n    /**\n     * Converts a string to an ArrayBuffer.\n     * @param  {string} text\n     * @return {ArrayBuffer}\n     */\n  }, {\n    key: \"stringToArrayBuffer\",\n    value: function stringToArrayBuffer(text) {\n      if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(text).buffer;\n      }\n      var array = new Uint8Array(new ArrayBuffer(text.length));\n      for (var i = 0, il = text.length; i < il; i++) {\n        var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n        array[i] = value > 0xff ? 0x20 : value;\n      }\n      return array.buffer;\n    }\n  }, {\n    key: \"isIdentityMatrix\",\n    value: function isIdentityMatrix(matrix) {\n      return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(attribute, start, count) {\n      var output = {\n        min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n        max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n      };\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (value !== undefined) {\n            output.min[a] = Math.min(output.min[a], value);\n            output.max[a] = Math.max(output.max[a], value);\n          }\n        }\n      }\n      return output;\n    }\n    /**\n     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n     */\n  }, {\n    key: \"getPaddedBufferSize\",\n    value: function getPaddedBufferSize(bufferSize) {\n      return Math.ceil(bufferSize / 4) * 4;\n    }\n    /**\n     * Returns a buffer aligned to 4-byte boundary.\n     *\n     * @param {ArrayBuffer} arrayBuffer Buffer to pad\n     * @param {Integer} paddingByte (Optional)\n     * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n     */\n  }, {\n    key: \"getPaddedArrayBuffer\",\n    value: function getPaddedArrayBuffer(arrayBuffer) {\n      var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n      if (paddedLength !== arrayBuffer.byteLength) {\n        var array = new Uint8Array(paddedLength);\n        array.set(new Uint8Array(arrayBuffer));\n        if (paddingByte !== 0) {\n          for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n            array[i] = paddingByte;\n          }\n        }\n        return array.buffer;\n      }\n      return arrayBuffer;\n    }\n  }]);\n  return GLTFWriter;\n}(); /**\n      * Punctual Lights Extension\n      *\n      * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n      */\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!(light instanceof DirectionalLight && light.isDirectionalLight) &&\n      // @ts-expect-error\n      !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light instanceof DirectionalLight && light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light instanceof PointLight &&\n      // @ts-expect-error\n      light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light instanceof SpotLight && light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n      if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      if (json.extensions !== undefined) {\n        var lights = json.extensions[this.name].lights;\n        lights.push(lightDef);\n        nodeDef.extensions = nodeDef.extensions || {};\n        nodeDef.extensions[this.name] = {\n          light: lights.length - 1\n        };\n      }\n    }\n  }]);\n  return GLTFLightExtension;\n}(); /**\n      * Unlit Materials Extension\n      *\n      * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n      */\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshBasicMaterial &&\n      // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}(); /**\n      * Specular-Glossiness Extension\n      *\n      * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n      */\nvar GLTFMaterialsPBRSpecularGlossiness = /*#__PURE__*/function () {\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    _classCallCheck(this, GLTFMaterialsPBRSpecularGlossiness);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n  _createClass(GLTFMaterialsPBRSpecularGlossiness, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      // @ts-expect-error\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n      if (material instanceof MeshPhongMaterial) {\n        var specularFactor = [1, 1, 1];\n        material.specular.toArray(specularFactor, 0);\n        extensionDef.specularFactor = specularFactor;\n        extensionDef.glossinessFactor =\n        // @ts-expect-error\n        material.glossiness;\n      }\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n        var specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsPBRSpecularGlossiness;\n}(); /**\n      * Transmission Materials Extension\n      *\n      * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n      */\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial &&\n      // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.transmission === 0) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap)\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}(); /**\n      * Materials Volume Extension\n      *\n      * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n      */\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial &&\n      // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.thickness === 0) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thickness = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap)\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor =\n      //@ts-expect-error\n      material.attenuationTint.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\nexport { GLTFExporter };","map":{"version":3,"names":["_defineProperty","PropertyBinding","InterpolateLinear","Vector3","RGBAFormat","ShaderMaterial","MeshStandardMaterial","MeshBasicMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshToonMaterial","MeshLambertMaterial","DoubleSide","LineSegments","LineLoop","Line","Points","MeshDepthMaterial","InterleavedBufferAttribute","BufferAttribute","Object3D","Material","OrthographicCamera","PerspectiveCamera","MathUtils","InterpolateDiscrete","SkinnedMesh","Matrix4","Mesh","Camera","Scene","DirectionalLight","PointLight","SpotLight","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","callback","indexOf","push","splice","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","insertKeyframe","track","time","tolerance","valueSize","getValueSize","times","TimeBufferType","values","ValueBufferType","interpolant","createInterpolant","index","Math","abs","set","evaluate","slice","mergeMorphTargetTracks","clip","root","tracks","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","parseTrackName","name","sourceTrackNode","findNode","nodeName","propertyName","propertyIndex","undefined","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","isInterpolantFactoryMethodGLTFCubicSpline","Error","console","warn","clone","setInterpolation","targetCount","morphTargetInfluences","targetIndex","morphTargetDictionary","mergedTrack","uuid","j","sourceInterpolant","keyframeIndex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","cachedCanvas","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","blob","Blob","type","extensionsUsedList","keys","byteLength","size","reader","window","FileReader","readAsArrayBuffer","onloadend","result","binaryChunk","getPaddedArrayBuffer","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","stringToArrayBuffer","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","object","objectDef","userData","parse","gltfExtensions","extensions","extensionName","extras","error","message","has","get","normal","v","count","fromBufferAttribute","attribute","x","y","z","setX","normalize","setXYZ","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buffer","componentType","start","target","bufferViews","componentSize","getPaddedBufferSize","itemSize","dataView","a","value","array","getX","getY","getZ","getW","setFloat32","setUint16","setUint8","bufferViewDef","processBuffer","byteStride","output","id","resolve","geometry","types","constructor","Float32Array","Uint32Array","Uint16Array","Uint8Array","end","end2","drawRange","max","min","minMax","getMinMax","bufferViewTarget","bufferView","processBufferView","accessorDef","normalized","accessors","image","format","flipY","cachedImages","mimeType","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","data","Uint8ClampedArray","ImageData","putImageData","toBlob","processBufferViewImage","bufferViewIndex","toDataURL","Image","src","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","textureDef","sampler","processSampler","source","processImage","_invokeAll","ext","writeTexture","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","equalArray","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","processTexture","applyTextureTransform","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","serializeUserData","writeMaterial","mesh","meshCacheKeyParts","Array","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","isNormalizedNormalAttribute","setAttribute","createNormalizedNormalAttribute","modifiedAttribute","attributeName","substr","toUpperCase","validVertexAttributes","test","getUID","accessor","processAccessor","weights","targetNames","reverseDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","targetMaterials","processMaterial","writeMesh","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","Utils","channels","trackBinding","trackNode","trackProperty","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","interpolation","getInterpolation","node","path","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","nodeDef","translation","matrixAutoUpdate","updateMatrix","isIdentityMatrix","matrix","elements","String","isMesh","meshIndex","processMesh","isCamera","processCamera","children","child","visible","nodeIndex","processNode","writeNode","scene","scenes","sceneDef","objects","processScene","beforeParse","objectsWithoutScene","inputScene","processObjects","processSkin","processAnimation","afterParse","func","array1","array2","every","element","text","TextEncoder","encode","charCodeAt","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","bufferSize","ceil","arrayBuffer","paddingByte","paddedLength","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","attenuationTint"],"sources":["/Users/trudypainter/Desktop/latent internet mirror/frontend/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nclass GLTFExporter {\n  constructor() {\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n  /**\n   * Static utility functions\n   */\n\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize(); // @ts-expect-error\n\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if ( // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n});\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546c67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\n\nclass GLTFWriter {\n  constructor() {\n    _defineProperty(this, \"plugins\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"pending\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"byteOffset\", void 0);\n\n    _defineProperty(this, \"nodeMap\", void 0);\n\n    _defineProperty(this, \"skins\", void 0);\n\n    _defineProperty(this, \"extensionsUsed\", void 0);\n\n    _defineProperty(this, \"uids\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"cachedCanvas\", void 0);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    const writer = this;\n    Promise.all(this.pending).then(() => {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n      const blob = new Blob(buffers, {\n        type: 'application/octet-stream'\n      }); // Declare extensions.\n\n      const extensionsUsedList = Object.keys(extensionsUsed);\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n      if (options.binary) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          if (reader.result !== null && typeof reader.result !== 'string') {\n            // Binary chunk.\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = function () {\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                onDone(glbReader.result);\n              }\n            };\n          }\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n\n          reader.onloadend = function () {\n            const base64data = reader.result;\n\n            if (json.buffers !== undefined && base64data !== null) {\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            }\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      if (error instanceof Error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n  }\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(resolve => {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = () => {\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n          const buffer = this.getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        }\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = this.getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    if (bufferViewTarget !== undefined) {\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\n\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages && options.maxTextureSize !== undefined) {\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n      }\n\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBA format is supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (image instanceof ImageData) {\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n        }\n\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary) {\n        pending.push(new Promise(function (resolve) {\n          canvas.toBlob(function (blob) {\n            if (blob !== null) {\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                resolve();\n              });\n            }\n          }, mimeType);\n        }));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else if (image instanceof Image) {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    if (cachedImages !== undefined) cachedImages[key] = index;\n    return index;\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n      // pbrMetallicRoughness.baseColorFactor\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n    }\n\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap)\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      } else {\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n      }\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh instanceof Line && mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh instanceof Points && mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          const accessor = this.processAccessor(relativeAttribute, geometry);\n\n          if (accessor != undefined) {\n            target[gltfAttributeName] = accessor;\n          }\n\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n\n      if (geometry instanceof Object3D || geometry instanceof Material) {\n        this.serializeUserData(geometry, primitive);\n      }\n\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          // @ts-expect-error\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const materialIndex = groups[i].materialIndex;\n\n      if (materialIndex !== undefined && Array.isArray(materials)) {\n        const targetMaterials = materials[materialIndex];\n\n        if (!Array.isArray(targetMaterials)) {\n          const material = this.processMaterial(targetMaterials);\n          if (material !== null) primitive.material = material;\n          primitives.push(primitive);\n        }\n      }\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (camera instanceof OrthographicCamera && isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else if (camera instanceof PerspectiveCamera) {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      // @ts-expect-error\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!this.equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!this.equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (!this.isIdentityMatrix(object.matrix)) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object instanceof Camera && object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || !options.onlyVisible) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || !options.onlyVisible) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      const inputScene = input[i];\n\n      if (inputScene instanceof Scene) {\n        this.processScene(inputScene);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  } //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n\n  equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n\n  isIdentityMatrix(matrix) {\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          output.min[a] = Math.min(output.min[a], value);\n          output.max[a] = Math.max(output.max[a], value);\n        }\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   */\n\n\n  getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n}\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light instanceof PointLight && // @ts-expect-error\n    light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light instanceof SpotLight && light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    if (json.extensions !== undefined) {\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    // @ts-expect-error\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    if (material instanceof MeshPhongMaterial) {\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = // @ts-expect-error\n      material.glossiness;\n    }\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.thickness === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thickness = material.thickness;\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = //@ts-expect-error\n    material.attenuationTint.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n\nexport { GLTFExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}