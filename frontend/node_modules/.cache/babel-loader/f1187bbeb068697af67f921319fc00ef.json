{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nvar shaderStages = ['fragment', 'vertex'];\nvar vector = ['x', 'y', 'z', 'w'];\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    _classCallCheck(this, NodeBuilder);\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n  _createClass(NodeBuilder, [{\n    key: \"addStack\",\n    value: function addStack(node) {\n      /*\n      if ( this.stack.indexOf( node ) !== - 1 ) {\n      console.warn( 'Recursive node: ', node );\n      }\n      */\n      this.stack.push(node);\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack(node) {\n      var lastStack = this.stack.pop();\n      if (lastStack !== node) {\n        throw new Error('NodeBuilder: Invalid node stack!');\n      }\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.indexOf(node) === -1) {\n        var updateType = node.getUpdateType(this);\n        if (updateType !== NodeUpdateType.None) {\n          this.updateNodes.push(node);\n        }\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getTextureBias\",\n    value: function getTextureBias() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTexture\",\n    value: function getCubeTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTextureBias\",\n    value: function getCubeTextureBias() {\n      console.warn('Abstract function.');\n    } // @TODO: rename to .generateConst()\n  }, {\n    key: \"getConst\",\n    value: function getConst(type, value) {\n      var _this = this;\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') {\n        return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      }\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n      var getConst = function getConst(value) {\n        return _this.getConst(componentType, value);\n      };\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \", \").concat(getConst(value.w), \" )\");\n      }\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes; // find attribute\n      var _iterator = _createForOfIteratorHelper(attributes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _attribute = _step.value;\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        } // create a new if no exist\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node\n    /*, shaderStage*/) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler';\n    }\n  }, {\n    key: \"isShaderStage\",\n    value: function isShaderStage(shaderStage) {\n      return this.shaderStage === shaderStage;\n    }\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      var encoding;\n      if (map && map.isTexture) {\n        encoding = map.encoding;\n      } else if (map && map.isWebGLRenderTarget) {\n        encoding = map.texture.encoding;\n      } else {\n        encoding = LinearEncoding;\n      }\n      return encoding;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(type) {\n      if (type === 1) return 'float';\n      if (type === 2) return 'vec2';\n      if (type === 3) return 'vec3';\n      if (type === 4) return 'vec4';\n      return 0;\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var nodeData = this.nodesData.get(node);\n      if (nodeData === undefined) {\n        nodeData = {\n          vertex: {},\n          fragment: {}\n        };\n        this.nodesData.set(node, nodeData);\n      }\n      return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, shaderStage, type) {\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeUniform = nodeData.uniform;\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage];\n        var index = vars.length;\n        nodeVar = new NodeVar('nodeVar' + index, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryFromNode\",\n    value: function getVaryFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node, null);\n      var nodeVary = nodeData.vary;\n      if (nodeVary === undefined) {\n        var varys = this.varys;\n        var index = varys.length;\n        nodeVary = new NodeVary('nodeVary' + index, type);\n        varys.push(nodeVary);\n        nodeData.vary = nodeVary;\n      }\n      return nodeVary;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage];\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n      return nodeCode;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(shaderStage, node) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      this.node = node;\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      this.node = null;\n      return flowData;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(propertyName, \" = \").concat(flowData.result, \";\\n\\t\");\n      }\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVarys\",\n    value: function getVarys() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n      for (var index = 0; index < vars.length; index++) {\n        var variable = vars[index];\n        snippet += \"\".concat(variable.type, \" \").concat(variable.name, \"; \");\n      }\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n      var _iterator2 = _createForOfIteratorHelper(codes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var nodeCode = _step2.value;\n          code += nodeCode.code + '\\n';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // stage 1: analyze nodes to possible optimization and validation\n      var _iterator3 = _createForOfIteratorHelper(shaderStages),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var shaderStage = _step3.value;\n          this.setShaderStage(shaderStage);\n          var flowNodes = this.flowNodes[shaderStage];\n          var _iterator5 = _createForOfIteratorHelper(flowNodes),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var node = _step5.value;\n              node.analyze(this);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } // stage 2: pre-build vertex code used in fragment shader\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      } // stage 3: generate shader\n      var _iterator4 = _createForOfIteratorHelper(shaderStages),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _shaderStage = _step4.value;\n          this.setShaderStage(_shaderStage);\n          var _flowNodes = this.flowNodes[_shaderStage];\n          var _iterator6 = _createForOfIteratorHelper(_flowNodes),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _node = _step6.value;\n              this.flowNode(_node, _shaderStage);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      this.setShaderStage(null); // stage 4: build code for a specific output\n\n      this.buildCode();\n      return this;\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n      if (fromTypeLength === 0) {\n        // fromType is matrix-like\n        var vectorType = this.getVectorFromMatrix(fromType);\n        return this.format(\"( \".concat(snippet, \" * \").concat(this.getType(vectorType), \"( 1.0 ) )\"), vectorType, toType);\n      }\n      if (toTypeLength === 0) {\n        // toType is matrix-like\n        // ignore for now\n        //return `${ this.getType( toType ) }( ${ snippet } )`;\n        return snippet;\n      }\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength), toType);\n      }\n      if (toTypeLength === 4) {\n        // toType is vec4-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n  return NodeBuilder;\n}();\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","push","lastStack","pop","Error","hash","indexOf","updateType","getUpdateType","None","setHashNode","getHash","method","console","warn","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","getConst","x","y","z","w","name","attribute","test","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","vecType","vecNum","replace","nodeData","get","undefined","set","getDataFromNode","nodeUniform","uniform","nodeVar","variable","length","nodeVary","vary","nodeCode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","propertyName","previousShaderStage","setShaderStage","snippet","analyze","isNode","flowNodeFromShaderStage","flowNode","buildCode","fromType","toType","isReference","fromTypeLength","toTypeLength","vectorType","getVectorFromMatrix","format","slice","getTypeFromLength"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}