{"ast":null,"code":"import _classCallCheck from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/trudypainter/Desktop/latent-2/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from 'three';\nvar PINCH_MAX = 0.05;\nvar PINCH_THRESHOLD = 0.02;\nvar PINCH_MIN = 0.01;\nvar POINTER_ADVANCE_MAX = 0.02;\nvar POINTER_OPACITY_MAX = 1;\nvar POINTER_OPACITY_MIN = 0.4;\nvar POINTER_FRONT_RADIUS = 0.002;\nvar POINTER_REAR_RADIUS = 0.01;\nvar POINTER_REAR_RADIUS_MIN = 0.003;\nvar POINTER_LENGTH = 0.035;\nvar POINTER_SEGMENTS = 16;\nvar POINTER_RINGS = 12;\nvar POINTER_HEMISPHERE_ANGLE = 110;\nvar YAXIS = new THREE.Vector3(0, 1, 0);\nvar ZAXIS = new THREE.Vector3(0, 0, 1);\nvar CURSOR_RADIUS = 0.02;\nvar CURSOR_MAX_DISTANCE = 1.5;\nvar OculusHandPointerModel = /*#__PURE__*/function (_THREE$Object3D) {\n  _inherits(OculusHandPointerModel, _THREE$Object3D);\n  var _super = _createSuper(OculusHandPointerModel);\n  function OculusHandPointerModel(hand, controller) {\n    var _this;\n    _classCallCheck(this, OculusHandPointerModel);\n    _this = _super.call(this);\n    _this.hand = hand;\n    _this.controller = controller;\n    _this.motionController = null;\n    _this.envMap = null;\n    _this.mesh = null;\n    _this.pointerGeometry = null;\n    _this.pointerMesh = null;\n    _this.pointerObject = null;\n    _this.pinched = false;\n    _this.attached = false;\n    _this.cursorObject = null;\n    _this.raycaster = null;\n    hand.addEventListener('connected', function (event) {\n      var xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        _this.visible = true;\n        _this.xrInputSource = xrInputSource;\n        _this.createPointer();\n      }\n    });\n    return _this;\n  }\n  _createClass(OculusHandPointerModel, [{\n    key: \"_drawVerticesRing\",\n    value: function _drawVerticesRing(vertices, baseVector, ringIndex) {\n      var segmentVector = baseVector.clone();\n      for (var i = 0; i < POINTER_SEGMENTS; i++) {\n        segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n        var vid = ringIndex * POINTER_SEGMENTS + i;\n        vertices[3 * vid] = segmentVector.x;\n        vertices[3 * vid + 1] = segmentVector.y;\n        vertices[3 * vid + 2] = segmentVector.z;\n      }\n    }\n  }, {\n    key: \"_updatePointerVertices\",\n    value: function _updatePointerVertices(rearRadius) {\n      var vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n      var frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n      this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n      var rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n      for (var i = 0; i < POINTER_RINGS; i++) {\n        this._drawVerticesRing(vertices, rearBase, i + 1);\n        rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n      } // front and rear face center vertices\n\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      var frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n      vertices[frontCenterIndex * 3] = frontCenter.x;\n      vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n      vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n      var rearCenter = new THREE.Vector3(0, 0, rearRadius);\n      vertices[rearCenterIndex * 3] = rearCenter.x;\n      vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n      vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n      this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n    }\n  }, {\n    key: \"createPointer\",\n    value: function createPointer() {\n      var i, j;\n      var vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n      var indices = [];\n      this.pointerGeometry = new THREE.BufferGeometry();\n      this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n      this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n      for (i = 0; i < POINTER_RINGS; i++) {\n        for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n          indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n          indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        }\n        indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n        indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      } // construct front and rear face\n\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n        indices.push(frontCenterIndex, i + 1, i);\n        indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n      }\n      indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n      indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n      var material = new THREE.MeshBasicMaterial();\n      material.transparent = true;\n      material.opacity = POINTER_OPACITY_MIN;\n      this.pointerGeometry.setIndex(indices);\n      this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerObject = new THREE.Object3D();\n      this.pointerObject.add(this.pointerMesh);\n      this.raycaster = new THREE.Raycaster(); // create cursor\n\n      var cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n      var cursorMaterial = new THREE.MeshBasicMaterial();\n      cursorMaterial.transparent = true;\n      cursorMaterial.opacity = POINTER_OPACITY_MIN;\n      this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n      this.pointerObject.add(this.cursorObject);\n      this.add(this.pointerObject);\n    }\n  }, {\n    key: \"_updateRaycaster\",\n    value: function _updateRaycaster() {\n      if (this.raycaster) {\n        var pointerMatrix = this.pointerObject.matrixWorld;\n        var tempMatrix = new THREE.Matrix4();\n        tempMatrix.identity().extractRotation(pointerMatrix);\n        this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n        this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      }\n    }\n  }, {\n    key: \"_updatePointer\",\n    value: function _updatePointer() {\n      this.pointerObject.visible = this.controller.visible;\n      var indexTip = this.hand.joints['index-finger-tip'];\n      var thumbTip = this.hand.joints['thumb-tip'];\n      var distance = indexTip.position.distanceTo(thumbTip.position);\n      var position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n      this.pointerObject.position.copy(position);\n      this.pointerObject.quaternion.copy(this.controller.quaternion);\n      this.pinched = distance <= PINCH_THRESHOLD;\n      var pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n      var focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n      if (pinchScale > 1) {\n        this._updatePointerVertices(POINTER_REAR_RADIUS);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      } else if (pinchScale > 0) {\n        var rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n        this._updatePointerVertices(rearRadius);\n        if (focusScale < 1) {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n        } else {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n        }\n      } else {\n        this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n      }\n      this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(OculusHandPointerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n      if (this.pointerGeometry) {\n        this._updatePointer();\n        this._updateRaycaster();\n      }\n    }\n  }, {\n    key: \"isPinched\",\n    value: function isPinched() {\n      return this.pinched;\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached(attached) {\n      this.attached = attached;\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.attached;\n    }\n  }, {\n    key: \"intersectObject\",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObject(object, recursive);\n      }\n    }\n  }, {\n    key: \"intersectObjects\",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObjects(objects, recursive);\n      }\n    }\n  }, {\n    key: \"checkIntersections\",\n    value: function checkIntersections(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.raycaster && !this.attached) {\n        var intersections = this.raycaster.intersectObjects(objects, recursive);\n        var direction = new THREE.Vector3(0, 0, -1);\n        if (intersections.length > 0) {\n          var intersection = intersections[0];\n          var distance = intersection.distance;\n          this.cursorObject.position.copy(direction.multiplyScalar(distance));\n        } else {\n          this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n        }\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(distance) {\n      var direction = new THREE.Vector3(0, 0, -1);\n      if (this.raycaster && !this.attached) {\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      }\n    }\n  }]);\n  return OculusHandPointerModel;\n}(THREE.Object3D);\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","addEventListener","event","xrInputSource","data","visible","createPointer","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","rearRadius","attributes","position","array","frontFaceBase","_drawVerticesRing","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","_updatePointerVertices","push","material","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","Object3D","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","force","_updatePointer","_updateRaycaster","object","recursive","intersectObject","objects","intersectObjects","intersections","length","intersection"],"sources":["/Users/trudypainter/Desktop/latent-2/frontend/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n      this._updatePointerVertices(rearRadius);\n\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.pointerGeometry) {\n      this._updatePointer();\n\n      this._updateRaycaster();\n    }\n  }\n\n  isPinched() {\n    return this.pinched;\n  }\n\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  isAttached() {\n    return this.attached;\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}